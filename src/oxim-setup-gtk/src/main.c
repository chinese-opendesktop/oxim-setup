/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#include "oxim_setup_gtk_global.h"
#include "chewing.h"
#include "gencin.h"
#include "globalsetting.h"
#include "installim.h"
#include "oxim_setting_and_config.h"
#include "g_oxim_conf.h"
#include "g_mirrors_site.h"
#include "installim_core_embassador.h"
#include "installim_gui_embassador.h"
#include "im_default_value.h"
#include "phrase_record.h"
#include <stdio.h>
#include <curl/curl.h>
#include <curl/types.h>
#include <curl/easy.h>



typedef enum
{
	OP_INIT,
	OP_GET_DATA,
	OP_REMOVE_SELECTION,
	OP_SAVE_FILE,
	OP_CONNECT_SELECTION,
	OP_DOWNLOAD,
}operation_t;


typedef enum
{
	IM_REC_TURN_ON=0,
	IM_REC_DEFAULT_ON,
	IM_REC_INPUT_METHOD_NAME,
	IM_REC_INPUT_METHOD_ALIAS_NAME,
	IM_REC_FAST_KEY,
	IM_REC_IM_BUILDIN,
} im_rec_t;

typedef struct
{
//	GladeXML* xml;
	GtkBuilder *builder;
}main_ref_t;


typedef struct
{	
	main_ref_t *ref;
	guint fail;
	gboolean has_init;
	GtkTreeView* treeview;
	GtkListStore* list_store;
}phase_tree_view_ref_t;

typedef struct
{
	main_ref_t *ref;
	guint fail;
	gboolean has_init;
	GtkTextView *textview;
	GtkTextBuffer *textview_buffer;
}icon_text_view_ref_t;

typedef struct
{
	main_ref_t *ref;
	guint fail;
	gboolean has_init;
	GtkTreeView* treeview;
	GtkListStore* list_store;
}im_tree_view_ref_t;


typedef struct
{
	main_ref_t *ref;
	guint fail;
	gboolean has_init;
	GtkTreeView* treeview;
	GtkListStore* list_store;
}mrrrsites_tree_view_ref_t;

typedef struct
{
	main_ref_t *ref;
	guint fail;
	gboolean has_init;
	GtkTreeView* treeview;
	GtkTreeStore* tree_store;
}mrrrcontents_tree_view_ref_t;


typedef struct
{
	main_ref_t* main;
	phase_tree_view_ref_t* phase_tree_view;
	icon_text_view_ref_t* icon_text_view;
	im_tree_view_ref_t* im_tree_view;
	mrrrsites_tree_view_ref_t* mrrrsites_tree_view;
	mrrrcontents_tree_view_ref_t* mrrrcontents_tree_view;
}global_ref_t;
static GtkWidget* treeview_popup_item_def=NULL;
static GtkWidget* treeview_popup_item_gen=NULL;
static GtkWidget* treeview_popup_item_pro=NULL;
static GtkWidget* treeview_popup_item_rem=NULL;

static GtkWidget* right_popup_menu = NULL;
//static gboolean mouse_right_button_is_clicked = FALSE;
gboolean popup_im_menu(GtkWidget* eventbox, GdkEventButton *event, GtkWidget* menu);

static void set_default_font_name(const gchar* set_data);
static const gchar* get_default_font_name(void);

void on_window_destroy (GtkWidget*, gpointer);
gboolean on_window_delete_event (GtkWidget*, GdkEvent*, gpointer);


void phrase_cell_data_func (GtkTreeViewColumn *column,  GtkCellRenderer *renderer,  GtkTreeModel *model,  GtkTreeIter *iter,  gpointer data);
void fast_key_cell_data_func (GtkTreeViewColumn *column,  GtkCellRenderer *renderer,  GtkTreeModel *model,  GtkTreeIter *iter,  gpointer data);
void im_buildin_cell_data_func (GtkTreeViewColumn *column,  GtkCellRenderer *renderer,  GtkTreeModel *model,  GtkTreeIter *iter,  gpointer data);
void apply_pixbuf_cell_data_func (GtkTreeViewColumn *column,  GtkCellRenderer *renderer,  GtkTreeModel *model,  GtkTreeIter *iter,  gpointer data);
void input_method_alias_name_cell_data_func (GtkTreeViewColumn *column,  GtkCellRenderer *renderer,  GtkTreeModel *model,  GtkTreeIter *iter,  gpointer data);




void fixed_toggled ( GtkCellRendererToggle *cell, gchar *path_str, gpointer data);
void default_button_clicked(GtkButton* default_button);
void global_button_clicked(GtkButton* default_button);
void property_button_clicked(GtkButton* property_button);
void add_im_button_clicked(GtkButton* add_im_button);
void delete_im_button_clicked(GtkButton* delete_im_button);
void window_ctor(GtkWidget* me);
void window_dtor(GtkObject* me);

void phase_tree_view_cell_edited (GtkCellRendererText *renderer, gchar *path, gchar *new_text, GtkTreeView *treeview);
void im_tree_view_cursor_changed(GtkTreeView* treeview, im_tree_view_ref_t* mine);


icon_text_view_ref_t* icon_text_view(main_ref_t* me, operation_t op, gpointer arg);
void icon_text_view_init(icon_text_view_ref_t* me, gpointer arg);

phase_tree_view_ref_t* phase_tree_view(main_ref_t* me, operation_t op, gpointer arg);
void phase_tree_view_init(phase_tree_view_ref_t* mine, gpointer arg);

im_tree_view_ref_t *im_tree_view(main_ref_t* me, operation_t op,gpointer arg);
void im_tree_view_init(im_tree_view_ref_t* mine, gpointer arg);
void im_tree_view_remove_selection(im_tree_view_ref_t* mine, gpointer arg);
void im_tree_view_save_file(im_tree_view_ref_t* mine, gpointer arg);

mrrrsites_tree_view_ref_t* mrrrsites_tree_view(main_ref_t* me, operation_t op,gpointer arg );
void mrrrsites_tree_view_init(mrrrsites_tree_view_ref_t* mine, gpointer arg);
void mrrrsites_tree_view_connect_selection(mrrrsites_tree_view_ref_t* mine, gpointer arg);


mrrrcontents_tree_view_ref_t* mrrrcontents_tree_view(main_ref_t* me, operation_t op,gpointer arg );
void mrrrcontents_tree_view_init(mrrrcontents_tree_view_ref_t* mine, gpointer arg);


void menu_item_test(GtkMenuItem* item, gchar* str); //for imtreeview's popupmenu -item

void menu_item_callback(GtkMenuItem *me, gpointer user_data[]);
int progress_callback(GtkWidget *progress_data,  double dltotal, double dlnow,  double ultotal, double ulnow);






phrases_t phase_strlist;
gint phase_strlist_size;

global_ref_t *global;
GtkWidget *window;

GtkWidget *delete_im_button;
static main_ref_t* main_mine=NULL;
int main(int argc, char *argv[])
{
  g_dir_mkpath("/",g_strdup_printf( "%s/.oxim/tables/%s", g_get_usertmp_dir(),g_get_user_name()));
  system("oxim-agent -r");
  gchar* mirrors_site_download_pos = g_strdup_printf("%s/.oxim/mirrors.site", g_get_userhome_dir());
  gboolean mirrors_site_need_update= FALSE;
 
  if(!g_file_test(mirrors_site_download_pos, G_FILE_TEST_EXISTS))
  {
    mirrors_site_need_update = TRUE;
  }
  else
  {
    struct stat buf;
//    time_t tim;
    if(0== g_stat(mirrors_site_download_pos,&buf))
    {
	GDate *gdate = g_date_new();
	g_date_set_time_t(gdate, buf.st_mtime);
	GDateDay day = g_date_get_day(gdate);
	GDateMonth month = g_date_get_month(gdate);
	GDateYear year = g_date_get_year(gdate);
	GTimeVal gtimeval;
	g_get_current_time(&gtimeval);
	g_date_free(gdate);
	gdate = g_date_new();
	g_date_set_time_val(gdate, &gtimeval);

	if (day != g_date_get_day(gdate) ||
	month != g_date_get_month(gdate) ||
	year != g_date_get_year(gdate) )
	{
	  g_printf("(%s:%d)[%s()] the date of mirrors.site is out-of-date\n",__FILE__, __LINE__, __func__);
	  mirrors_site_need_update=TRUE;
	
	}
	g_date_free(gdate);
    }
  }


  if(mirrors_site_need_update)
  {
    if(im_core_ftp_download( "http://opendesktop.org.tw/mirrors.site", mirrors_site_download_pos, 3))
    {
	g_printf("(%s:%d)[%s()]mirrors.site download succeed\n", __FILE__, __LINE__, __func__);
    }
    else
    {
	g_printf("(%s:%d)[%s()]mirrors.site download error\n", __FILE__, __LINE__, __func__);
    }
  }

  //gchar *cmd =NULL;
  //cmd = g_strdup_printf("wget http://opendesktop.org.tw/mirrors.site ", );
  //system("http://opendesktop.org.tw/mirrors.site

  static main_ref_t mine = {NULL}; 
  static global_ref_t global_inst={NULL,NULL,NULL,NULL};
  gtk_rc_parse(GTKRC_FILEPATH);

  //GladeXML *xml;
  GtkBuilder *builder;

  gtk_set_locale(); //for i18n
  bindtextdomain (GETTEXT_PACKAGE, "/usr/share/locale"); //for i18n
  textdomain (GETTEXT_PACKAGE);//for i18n

  //gtk_glade_binetextdomain(GETTEXT_PACKAGE, "/usr/share/locale");
  //gtk_glade_textdomain(GETTEXT_PACKAGE);
  
  gtk_init (&argc, &argv);

  //show_result();
  if(!g_oxim_conf_reload())
  {
    
  }

  if(!g_oxim_conf_correct()) g_printf("\n\nError for g_oxim_conf_correct()\n\n");
  g_mirrors_site_reload();

  g_printf("show host name start\n");
  gchar* ret_hostname;
  if(g_mirrors_site_first_hostname(&ret_hostname))
  {
    do{
	gchar* ss;
	gchar empty_str[]="";
	g_printf("hostname = %s , ftp = %s\n", ret_hostname, g_mirrors_site_get(ret_hostname,"ftp",&ss)? ss: empty_str );
	if(ss==NULL)g_free(ss);
	g_free(ret_hostname);
    }while(g_mirrors_site_next_hostname(&ret_hostname));
  }
  g_printf("show host name end\n");

  if(1) //test *_dir() function
  {
    g_printf("g_get_home_dir() ret %s\n", g_get_home_dir());
    g_printf("g_get_user_name() ret %s\n", g_get_user_name());
    
  }
  if(1) //test g_hash_table_mget_keys() of utils.h
  {
	GList **plist;
	GList *tmp_list=NULL;
	plist = &tmp_list;
	
	GHashTable* ht=NULL;
	ht = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
	g_hash_table_insert(ht, g_strdup("abc"), g_strdup("cde"));
	g_hash_table_insert(ht, g_strdup("Abc"), g_strdup("Cde"));
	g_hash_table_insert(ht, g_strdup("ABC"), g_strdup("CDE"));


	GList * list = g_hash_table_mget_keys(ht);
	g_printf("(%s:%d)[%s()] Start to show the funciton of the func ... g_hash_table_mget_keys()\n", __FILE__, __LINE__, __func__);
	list = g_list_first(list);
	while(list!=NULL)
	{
	  g_printf("key=%s\n",(gchar*)list->data);
	  list = g_list_next(list);
	}

	g_list_free(list);	
	g_printf("(%s:%d)[%s()] Start to show the funciton of the func ... g_hash_table_mget_keys()\n", __FILE__, __LINE__, __func__);

  } 

  //xml = glade_xml_new (GLADE_FILEPATH, "window", NULL);
  GError* error = NULL;
  builder = gtk_builder_new();

 if( !gtk_builder_add_from_file( builder, GLADE_FILEPATH, &error ) )
  {
    g_warning( "Couldn't load builder file: %s", error->message );
    g_error_free(error);
  }


//  window = glade_xml_get_widget (xml, "window");
  window = GTK_WIDGET( gtk_builder_get_object(builder, "window") );


  gtk_window_set_resizable( GTK_WINDOW(window), FALSE );

//  gtk_window_resize( GTK_WINDOW(window),400,200 );


//  glade_xml_signal_autoconnect (xml);
  gtk_builder_connect_signals( builder, NULL );

//  mine.xml = xml;
  mine.builder = builder;
  if(main_mine==NULL)main_mine = &mine;

  if(icon_text_view(&mine, OP_INIT, NULL)->fail)	printf("icon_text_view init fail\n");
  if(phase_tree_view(&mine, OP_INIT, NULL)->fail)	printf("phase_tree_view init fail\n");
  if(im_tree_view(&mine, OP_INIT, NULL)->fail)		printf("im_tree_view init fail\n");

  global_inst.main = &mine;
  global_inst.icon_text_view = icon_text_view(&mine, OP_GET_DATA, NULL);
  global_inst.phase_tree_view = phase_tree_view(&mine, OP_GET_DATA, NULL);
  global_inst.im_tree_view = im_tree_view(&mine, OP_GET_DATA, NULL);
  global_inst.mrrrsites_tree_view = mrrrsites_tree_view(&mine,OP_GET_DATA,NULL);
  global_inst.mrrrcontents_tree_view = mrrrcontents_tree_view(&mine,OP_GET_DATA,NULL);

  global = &global_inst;

//  delete_im_button = glade_xml_get_widget(xml,"delete_im_button");
  delete_im_button = GTK_WIDGET( gtk_builder_get_object(builder, "delete_im_button") );



  //GtkWidget* tmp_widget;
  static gboolean is_menu_created=FALSE;
  GtkMenu* menu = GTK_MENU(gtk_menu_new());
  if(!is_menu_created)
  {
    GtkWidget *item1, *item2, *item3, *item4;
    GtkWidget *sep;
    item1 = gtk_image_menu_item_new_with_label(_("Default"));
    item2 = gtk_image_menu_item_new_with_label(_("Gen. setting"));
    item3 = gtk_image_menu_item_new_with_label(_("Property"));
    item4 = gtk_image_menu_item_new_with_label(_("Remove IM")); 
    treeview_popup_item_def=item1;
    treeview_popup_item_gen=item2;
    treeview_popup_item_pro=item3;
    treeview_popup_item_rem=item4;


    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item1), gtk_image_new_from_stock(GTK_STOCK_APPLY,GTK_ICON_SIZE_MENU));
    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item2), gtk_image_new_from_stock(GTK_STOCK_EDIT,GTK_ICON_SIZE_MENU));
    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item3), gtk_image_new_from_stock(GTK_STOCK_PROPERTIES,GTK_ICON_SIZE_MENU));
    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item4), gtk_image_new_from_stock(GTK_STOCK_REMOVE,GTK_ICON_SIZE_MENU));
    //gtk_image_menu_item_set_image(item3, );

    sep = gtk_separator_menu_item_new();
    //g_signal_connect(G_OBJECT(item1), "activate", G_CALLBACK(menu_item_test), g_strdup(_("Default")));
    //g_signal_connect(G_OBJECT(item2), "activate", G_CALLBACK(menu_item_test), g_strdup(_("Gen. setting")));
    //g_signal_connect(G_OBJECT(item3), "activate", G_CALLBACK(menu_item_test), g_strdup(_("Property")));
    //g_signal_connect(G_OBJECT(item4), "activate", G_CALLBACK(menu_item_test), g_strdup(_("Remove IM"))); 
    g_signal_connect(G_OBJECT(item1), "activate", G_CALLBACK(default_button_clicked), NULL);
    g_signal_connect(G_OBJECT(item2), "activate", G_CALLBACK(global_button_clicked), NULL);
    g_signal_connect(G_OBJECT(item3), "activate", G_CALLBACK(property_button_clicked), NULL);
    g_signal_connect(G_OBJECT(item4), "activate", G_CALLBACK(delete_im_button_clicked), NULL);
 
    //GtkMenuShell* menu_shell = menu;

    gtk_menu_shell_append(GTK_MENU_SHELL(menu), item1); 
   gtk_menu_shell_append(GTK_MENU_SHELL(menu), gtk_separator_menu_item_new());

    gtk_menu_shell_append(GTK_MENU_SHELL(menu), item2);
    gtk_menu_shell_append(GTK_MENU_SHELL(menu), item3); 
   gtk_menu_shell_append(GTK_MENU_SHELL(menu), gtk_separator_menu_item_new());

    gtk_menu_shell_append(GTK_MENU_SHELL(menu), item4);
//    gtk_menu_attach_to_widget(menu, glade_xml_get_widget(xml,"IM_treeview"), NULL);
    gtk_menu_attach_to_widget(menu, GTK_WIDGET( gtk_builder_get_object(builder, "IM_treeview") ), NULL);
    is_menu_created=TRUE;
  }
//  g_signal_connect(G_OBJECT( glade_xml_get_widget(xml, "IM_treeview")), "button_press_event", G_CALLBACK(popup_im_menu), menu);
   g_signal_connect(G_OBJECT( GTK_WIDGET( gtk_builder_get_object(builder, "IM_treeview") ) ), "button_press_event", G_CALLBACK(popup_im_menu), menu);
  gtk_widget_show_all(GTK_WIDGET(menu));
//set data from oxim.conf's SystemSetting to GUI

	//GladeXML* xml =main_mine->xml;
//	GtkSpinButton *btn1 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton1"));
//	GtkSpinButton *btn2 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton2"));
//	GtkSpinButton *btn3 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton3"));
//	GtkSpinButton *btn4 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton4"));
//	GtkSpinButton *btn5 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton5"));
//	GtkSpinButton *btn6 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton6"));


	GtkSpinButton *btn1 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton1") ) );
	GtkSpinButton *btn2 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton2") ) );
	GtkSpinButton *btn3 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton3") ) );
	GtkSpinButton *btn4 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton4") ) );
	GtkSpinButton *btn5 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton5") ) );
	GtkSpinButton *btn6 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton6") ) );

	//g_oxim_conf_set("SystemSetting","PreeditFontSize",pINT(gtk_spin_button_get_value(btn1)),VT_INT);

	gint *ii;
#if 1
#define GET(attr,btn,default_value) gtk_spin_button_set_value(btn,  (g_oxim_conf_get("SystemSetting",(attr),&ii,VT_INT) ) ? *ii: 13)
	GET("PreeditFontSize",btn1,13);
	GET("SelectFontSize",btn2,16);
	GET("StatusFontSize",btn3,16);
	GET("MenuFontSize",btn4,13);
	GET("SymbolFontSize",btn5,13);
	GET("XcinFontSize",btn6,16);
#undef GET
#endif 
#if 0
	static gchar* font_name;
	g_oxim_conf_get("SystemSetting","DefaultFontName",&font_name,VT_STRING);
	if(!gtk_font_button_set_font_name( GTK_FONT_BUTTON(glade_xml_get_widget(xml,"fontbutton1")),font_name))
	{
		g_printf("(%s:%d)[%s()] Font Name in oxim.conf is not exist in the Desktop Environment\n",__FILE__,__LINE__,__func__);
		//TODO: set LINUX default font name
	}

//	g_utf8_str_assign( font_name,gtk_font_button_get_font_name(glade_xml_get_widget(xml,"fontbutton1")));
//	g_oxim_conf_set("SystemSetting","DefaultFontName",font_name,VT_STRING);

#else	
  #if 0
	static gchar* font_name;
	g_oxim_conf_get("SystemSetting","DefaultFontName",&font_name,VT_STRING);
	GtkComboBox* font_box = glade_xml_get_widget(xml, "combobox_fontfamily"); 
	if(font_box==NULL)
	{
	  g_printf("(%s:%d)[%s()]\n", __FILE__, __LINE__, __func__);
	}
	//font_box = gtk_combo_box_new_text();
	GList* font_list = gnome_font_family_list();
	GList* fl = g_list_first(font_list);
	while(fl!=NULL)
	{
	  gtk_combo_box_append_text(font_box, g_strdup(fl->data));
	  g_printf("font_family = %s\n", fl->data);
	  fl = g_list_next(fl);
	} //
	 gtk_combo_box_set_title(font_box, font_name);
	gnome_font_family_list_free(font_list);
  #else
    if(1)
    {
	static gchar* font_name;
	g_oxim_conf_get("SystemSetting","DefaultFontName",&font_name,VT_STRING);
	g_printf("Get DefaultFontName = %s\n",font_name);
	//font_box = gtk_combo_box_new_text();
	//static GtkOptionMenu* option_menu = NULL;
	GtkOptionMenu* option_menu;
//	option_menu = GTK_OPTION_MENU(glade_xml_get_widget(xml,"optionmenu_fontfamily"));
	option_menu = GTK_OPTION_MENU( GTK_WIDGET( gtk_builder_get_object(builder, "optionmenu_fontfamily") ) );
	GtkMenu *menu = GTK_MENU(gtk_menu_new());
	GList* font_list = gtk_font_family_list(GTK_WIDGET(window));
	
	GList* fl = g_list_first(font_list);
	GList* tmp = g_list_first(fl);
	int checked = 0;

	while( (tmp = g_list_next(tmp)) != NULL)
	{
		g_printf("AAAAfont_family = %s\n", (gchar*)tmp->data);
		if(g_utf8_str_equal(tmp->data, font_name))
		{
			checked = 1;
			break;
		}
	}
	if(!checked)
		fl = g_list_prepend(fl, font_name);
	
	//GList* menu_list = NULL;
	static GHashTable* hash_table = NULL;
	static gint int_idx = 0 ;
	static gint select_history = 0;
	while(fl!=NULL)
	{
	 // gtk_combo_box_append_text(font_box, g_strdup(fl->data));
	  if(hash_table==NULL)
	  {
	    hash_table = g_hash_table_new_full(g_int_hash, g_int_equal, g_slice_int_free, g_free);
	    int_idx=0;
	    select_history = 1; 
	  } 

	  g_printf("font_family = %s\n", (gchar*)fl->data);
	  gint* addr_gint = g_slice_alloc(sizeof(gint));
	  *addr_gint = int_idx;

	  g_hash_table_insert(hash_table, addr_gint, g_strdup(fl->data));
	  int_idx++;
	  GtkMenuItem * item = NULL;
	  item = GTK_MENU_ITEM(gtk_menu_item_new_with_label(g_strdup(fl->data)));
	  PangoFontDescription *fd;
	  //gchar *text = g_strdup_printf("%s %d",fl->data,16);
	  gchar *text = g_strdup_printf("%s",(gchar*)fl->data);
	  g_printf("test = %s, font_name=%s\n", text, font_name);
	  fd = pango_font_description_from_string (text);
	  gtk_widget_modify_font (GTK_WIDGET(item), fd);
	  pango_font_description_free (fd);

	  static gpointer user_data[2];
	  user_data[0] = option_menu;
	  user_data[1] = hash_table;
	  g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(menu_item_callback), user_data);

	  gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(item) );
	  if(g_utf8_str_equal(fl->data, font_name))
	  {
	    select_history = *addr_gint;
	  }
	  fl = g_list_next(fl);
	} //
	
	gtk_option_menu_set_menu(option_menu, GTK_WIDGET(menu));
	gtk_option_menu_set_history(option_menu, select_history);
	set_default_font_name( g_hash_table_lookup(hash_table, &select_history));
	gtk_font_family_list_free(font_list);
    }	

  #endif 	

	
#endif 
  gtk_widget_show_all (window);
  gtk_main ();
  return 0;

} //main()
void menu_item_callback(GtkMenuItem *me, gpointer user_data[])
{
	GtkOptionMenu* option_menu = user_data[0];
	GHashTable* hash_table = user_data[1];
	gint history = gtk_option_menu_get_history(option_menu);
	g_printf("\n Selecting %d -> %s\n", history,(gchar*) g_hash_table_lookup(hash_table, &history));
	set_default_font_name( g_hash_table_lookup(hash_table, &history));
} //menu_item_callback()

void window_accept(GtkWidget *me)
{
  printf("[Func %s() is invoked]\n",__func__);
 //TODO: store some data
  //g_oxim_conf_update();
  

	g_printf("[%s() is invoked]\n",__func__);
	//TODO: model from where?  ref how to use main_mine to get

//	GladeXML* xml =main_mine->xml;
//	GtkSpinButton *btn1 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton1"));
//	GtkSpinButton *btn2 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton2"));
//	GtkSpinButton *btn3 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton3"));
//	GtkSpinButton *btn4 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton4"));
//	GtkSpinButton *btn5 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton5"));
//	GtkSpinButton *btn6 = GTK_SPIN_BUTTON( glade_xml_get_widget (xml,"spinbutton6"));

	GtkBuilder *builder = main_mine->builder;
	GtkSpinButton *btn1 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton1") ) );
	GtkSpinButton *btn2 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton2") ) );
	GtkSpinButton *btn3 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton3") ) );
	GtkSpinButton *btn4 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton4") ) );
	GtkSpinButton *btn5 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton5") ) );
	GtkSpinButton *btn6 = GTK_SPIN_BUTTON( GTK_WIDGET( gtk_builder_get_object(builder, "spinbutton6") ) );


	//g_oxim_conf_set("SystemSetting","PreeditFontSize",pINT(gtk_spin_button_get_value(btn1)),VT_INT);


#define SET(attr,btn) g_oxim_conf_set("SystemSetting",(attr),pINT(gtk_spin_button_get_value(btn)),VT_INT)
	SET("PreeditFontSize",btn1);
	SET("SelectFontSize",btn2);
	SET("StatusFontSize",btn3);
	SET("MenuFontSize",btn4);
	SET("SymbolFontSize",btn5);
	SET("XcinFontSize",btn6);
//	gtk_spin_button_get_value(btn1);

#undef SET

	phrase_update(phase_strlist, phase_strlist_size);

//gchar*              gtk_font_selection_get_font_name    (GtkFontSelection *fontsel);
	static gchar font_name[255];
	//g_utf8_str_assign( font_name,gtk_font_button_get_font_name(GTK_FONT_BUTTON(glade_xml_get_widget(xml,"fontbutton1"))));
	g_utf8_str_assign( font_name, get_default_font_name());
	g_oxim_conf_set("SystemSetting","DefaultFontName",font_name,VT_STRING);
	g_printf("\nSet DefaultFontName = %s\n",get_default_font_name());
	


  if(im_tree_view(main_mine, OP_SAVE_FILE, NULL)->fail) 
	g_printf("(%s:%d)[%s()] im_tree_view save file fail\n", __FILE__, __LINE__, __func__);
  //TODO: save SystemSetting


  GList* l4hot = NULL; //The list for {the set {*.tab} in $HOME/.oxim/tables/}
  GList* l4toth = NULL;//The list for {the set {*.tab} in /tmp/.oxim/tables/$HOME}
  GList* l4oc = NULL; //The list for {im set in ~/.oxim/tables/oxim.conf

  //build l4hot (~/.oxim/tables/*.tab)
  if(1) //build l4hot (~/.oxim/tables/*.tab)
  {
   
    static gchar hot_fp[100]="";
    if(hot_fp[0]=='\0')
	g_sprintf(hot_fp, "%s/.oxim/tables/", g_get_userhome_dir());
    g_dir_curdir_push();
    if(-1 == g_chdir(hot_fp))
    {
	g_printf("(%s:%d)[%s()] Error! g_chdir(\"%s\")  return -1\n", __FILE__, __LINE__, __func__, hot_fp);
	g_dir_curdir_pop();
	return;
    }
    GError *error = NULL;
    GDir *gdir= g_dir_open(hot_fp,0,&error);
    if(error != NULL)
    {
	g_printf("(%s:%d)[%s()] Error! g_dir_open(\"%s\",0,&error) \n", __FILE__, __LINE__, __func__, hot_fp);
	g_print(error->message);
	g_clear_error(&error);	
	g_dir_curdir_pop();
	//return FALSE;
	return;
    }

    g_dir_rewind(gdir);
    const gchar* readname=NULL;
    readname = g_dir_read_name(gdir);
    while(readname!=NULL)
    {
	gint len=0;
	static gchar rn[100];
	g_utf8_str_assign(rn, readname);
	while(rn[len]!='\0')len++;
	if(g_utf8_str_equal(".tab", &(rn[len-4]) ))
	{
  	  rn[len-4]='\0';
	  l4hot = g_list_append(l4hot,g_strdup(rn));
	  l4hot = g_list_first(l4hot);
	}	
	readname = g_dir_read_name(gdir);
    }
    g_dir_close(gdir);
    g_dir_curdir_pop();
  }//if(1) //build l4hot (~/.oxim/tables/*.tab

  if(1)//build l4toth (/tmp/.xoim/tables/~/*.tab)
  { 
    static gchar toth_fp[100]="";
    if(toth_fp[0]=='\0')
	g_sprintf(toth_fp, "%s/.oxim/tables/%s/", g_get_usertmp_dir(),g_get_user_name());
    g_dir_curdir_push();
    if(-1 == g_chdir(toth_fp))
    {
	g_printf("(%s:%d)[%s()] Error! g_chdir(\"%s\")  return -1\n", __FILE__, __LINE__, __func__, toth_fp);
	g_dir_curdir_pop();
	return;
    }
    GError *error = NULL;
    GDir *gdir= g_dir_open(toth_fp,0,&error);
    if(error != NULL)
    {
	g_printf("(%s:%d)[%s()] Error! g_dir_open(\"%s\",0,&error) \n", __FILE__, __LINE__, __func__, toth_fp);
	g_print(error->message);
	g_clear_error(&error);	
	g_dir_curdir_pop();
	//return FALSE;
	return;
    }
    g_dir_rewind(gdir);
    const gchar* readname=NULL;
    readname = g_dir_read_name(gdir);
    while(readname!=NULL)
    {
	gint len=0;
	static gchar rn[100];
	g_utf8_str_assign(rn, readname);
	while(rn[len]!='\0')len++;
	if(g_utf8_str_equal(".tab", &(rn[len-4]) ))
	{
	  rn[len-4]='\0';
  	  l4toth = g_list_append(l4toth,g_strdup(rn));
	  l4toth = g_list_first(l4toth);
	}
	readname = g_dir_read_name(gdir);

    }

    g_dir_close(gdir);
    g_dir_curdir_pop();
  }//if(1)//build l4toth (/tmp/.xoim/tables/~/*.tab)

  if(1) //build l4oc (im(s) in ~/.oxim/tables/oxim.conf)
  {
    l4oc = NULL;
    gchar* text;
    if(g_oxim_conf_first_imtable(&text))
    {
     do{
	if(!g_utf8_str_equal(text,"SystemSetting"))
	{
	  g_printf("(%s:%d)[%s()] l4oc append %s \n",__FILE__, __LINE__, __func__,text);
	  l4oc = g_list_append(l4oc, text);
	  l4oc = g_list_first(l4oc);
	}
	//g_free(text);
     }while(g_oxim_conf_next_imtable(&text));
    }
  }//if(1) //build l4oc (im(s) in ~/.oxim/tables/oxim.conf)


  if(1) //show l4oc, l4hot, l4toth
  {
    GList* l;

    l=NULL;
    g_printf("\n l4oc=[");
    if(l4oc!=NULL)
    {
	l = l4oc;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_printf("%s, ",(gchar*)l->data);
	  l = g_list_next(l);
	}
    }
    g_printf("]\n");

    l=NULL;
    g_printf("\n l4hot=[");
    if(l4hot!=NULL)
    {
	l = l4hot;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_printf("%s, ",(gchar*)l->data);
	  l = g_list_next(l);
	}
    }
    g_printf("]\n");

    l=NULL;
    g_printf("\n l4toth=[");
    if(l4toth!=NULL)
    {
	l = l4toth;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_printf("%s, ",(gchar*)l->data);
	  l = g_list_next(l);
	}
    }
    g_printf("]\n");
  }//if(1) //show l4oc, l4hot, l4toth

  if(1) // for e in {l4hot} - {l4oc}; do remove e.tab from ~/.oxim/tables/
  {
    GList* L=NULL;
    GList* R=NULL;
    if(l4hot!=NULL)
    {
	L = g_list_first(l4hot);
	while(L!=NULL)
	{
	  gboolean need_remove = TRUE;
	  if(l4oc==NULL)
	  {
	    need_remove = TRUE;
	  }
	  else
	  {
	    R = g_list_first(l4oc);
	    if(R==NULL)
	    {
		need_remove = TRUE;
	    }
	    else
	    {
		while(R!=NULL)
		{
		  if(g_utf8_str_equal(L->data, R->data))
		  {
		    need_remove=FALSE;
		    
		    break;
		  }
		  R=g_list_next(R);
		}
	    }
	  }
	  
	  if(need_remove)
	  {
	    
	    static gchar cmd[100];
	    g_sprintf(cmd, "rm -f %s/.oxim/tables/%s.tab", g_get_userhome_dir(), (gchar*)L->data);
	    g_printf("(%s:%d)[%s()] remove %s By cmd=\"%s\"\n", __FILE__, __LINE__, __func__, (gchar*)L->data, cmd);
	    system(cmd);
	  }
	  else
	  {
	    g_printf("(%s:%d)[%s()] don't remove %s\n", __FILE__, __LINE__, __func__, (gchar*)L->data);
	  }

	  L=g_list_next(L);
	} //while(L!=NULL)
    }
  }// if(1) // for e in {l4hot} - {l4oc}; do remove e.tab from ~/.oxim/tables/; done


  if(1) // for e in {intersection of {l4oc} and {l4toth}}; do copy e to ~/.oxim/tables/; done
  { //mabye change copy into move
    GList* L=NULL;
    GList* R=NULL;
    if( (l4oc!=NULL) && (l4toth!=NULL))
    {
	L = g_list_first(l4oc);
	while(L!=NULL)
	{
	  gboolean need_copy=FALSE;
	  R = NULL;
	  R = g_list_first(l4toth);
	  while(R!=NULL)
	  {
	    if(g_utf8_str_equal(L->data, R->data))
	    {
		need_copy=TRUE;
		break;
	    }
	    R = g_list_next(R);
	  }

	  if(need_copy)
	  {
	    static gchar cmd[100];
	    g_sprintf(cmd, "install -Dm 644 %s/.oxim/tables/%s/%s.tab %s/.oxim/tables/%s.tab", g_get_usertmp_dir(), g_get_user_name(), (gchar*)R->data, g_get_userhome_dir(), (gchar*)R->data );
	    system(cmd);
	  }
	  L = g_list_next(L);
	}
    }
  }//  if(1) // for e in {intersection of {l4oc} and {l4toth}}; do copy e to ~/.oxim/tables/; done

  if(1) //update data from g_oxim_conf to ~/.oxim/oxim.conf
  {
    g_oxim_conf_update();
  }// if(1) //update data from g_oxim_conf to ~/.oxim/oxim.conf

  if(1)//release l4oc, l4hot, l4toth
  {
    GList* l;

    l=NULL;
    if(l4oc!=NULL)
    {
	l = l4oc;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_free(l->data);
	  l = g_list_next(l);
	} 
	g_list_free(l4oc);
    }

    l=NULL;
    if(l4hot!=NULL)
    {
	l = l4hot;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_free(l->data);
	  l = g_list_next(l);
	}
	g_list_free(l4hot);
    }

    l=NULL;
    if(l4toth!=NULL)
    {
	l = l4toth;
	l = g_list_first(l);
	while(l!=NULL)
	{
	  g_free(l->data);
	  l = g_list_next(l);
	}
 	g_list_free(l4toth);
    }
  } //if(1)//release l4oc, l4hot, l4toth



  if(0) //remove  {~/.oxim/tables/*.tab} - {g_oxim_conf}
  {
    //GList* lgoc=NULL;
   

  } //if(1) //remove  {~/.oxim/tables/*.tab} - {g_oxim_conf}
  if(0) //mv the tab from /tmp/.oxim/tables/~/*.tab to 
  {
/*
    gint len=0;
    gchar* filepath_tab;	
    static gchar cmd[255];

    g_printf("(%s:%d)[%s(im_name=%s, filepath=%s) invoked]\n", __FILE__, __LINE__, __func__,im_name,filepath_cin_gz);
    g_sprintf(cmd,"oxim2tab -o %s/.oxim/tables/%s/%s.tab %s", g_get_usertmp_dir(),g_get_user_name(),im_name,  filepath_cin_gz);
    system(cmd);  
    g_sprintf(cmd,"cp %s/.oxim/tables/%s/%s.tab %s/.oxim/tables/",g_get_usertmp_dir(),g_get_user_name(),im_name, g_get_userhome_dir() );
    system(cmd);
    g_oxim_conf_add_imtable(im_name);
*/
  } //if(1) //mv the tab from /tmp/.oxim/tables/~/*.tab to
  



	system("oxim-agent -r");
	

	//gdouble             gtk_spin_button_get_value           (GtkSpinButton *spin_button);
	//gtk_spin_button_set_value(GtkSpinButton *spin_button, gdouble value);

  window_dtor(GTK_OBJECT(window));

	
} //window_accept()

void window_reject(GtkWidget *me)
{
  printf("[Func %s() is invoked]\n",__func__);

  window_dtor(GTK_OBJECT(window));
} //window_reject()

void window_ctor(GtkWidget *me)
{
  printf("[Func %s() is invoked]\n",__func__);
} //window_ctor()

void window_dtor(GtkObject *me)
{
  printf("[Func %s() is invoked]\n",__func__);
  gtk_main_quit ();
} //window_dtor()

/* Stop the GTK+ main loop function. */
void on_window_destroy (GtkWidget *window, gpointer data)
{
  gtk_main_quit ();
} //destory()

/* Return FALSE to destroy the widget. By returning TRUE, you can cancel
 * a delete-event. This can be used to confirm quitting the application. */
gboolean on_window_delete_event (GtkWidget *window,
              GdkEvent *event,
              gpointer data)
{
  return FALSE;
} //delete_event()






void fixed_toggled ( GtkCellRendererToggle *cell, gchar *path_str, gpointer data)
{
  g_printf("[Func %s() is invoked]\n",__func__);
	GtkTreeModel *model = (GtkTreeModel *)data;
	GtkTreeIter iter;
	GtkTreePath *path = gtk_tree_path_new_from_string(path_str);
	gboolean fixed;

	gtk_tree_model_get_iter( model,&iter,path);
	gtk_tree_model_get(model, &iter, 0, &fixed, -1);
	fixed ^= 1 ;
	gtk_list_store_set (GTK_LIST_STORE(model), &iter, 0,fixed, -1);
	gtk_tree_path_free (path);


	//store the circular's value into g_oxim_conf
	gchar* im;
	gchar* vstr;
	gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
	if(!g_oxim_conf_query_eng_name(vstr, &im))g_printf("(%s:%d)[%s()]g_oxim_conf_query_eng_name(\"%s\",ret_im) return FALSE\n", __FILE__, __LINE__, __func__,vstr);
	g_oxim_conf_set(im, "Circular", fixed ? pTRUE() : pFALSE(), VT_BOOL);
}//fixed_toggled ()



void mirrrcontents_fixed_toggled ( GtkCellRendererToggle *cell, gchar *path_str, gpointer data)
{
  g_printf("[Func %s() is invoked]\n",__func__);
	GtkTreeModel *model = (GtkTreeModel *)data;
	GtkTreeIter iter;
	GtkTreePath *path = gtk_tree_path_new_from_string(path_str);
	gboolean fixed;

	gtk_tree_model_get_iter( model,&iter,path);
	gtk_tree_model_get(model, &iter, 0, &fixed, -1);
	fixed ^= 1 ;
	gtk_list_store_set (GTK_LIST_STORE(model), &iter, 0,fixed, -1);
	gtk_tree_path_free (path);
}//fixed_toggled ()



void default_button_clicked(GtkButton* default_button)
{
	g_printf("[Func %s() is invoked]\n",__func__);
	GtkTreeModel* model;
	GtkTreeIter iter;
	GtkTreeIter select_iter;
	GtkTreeSelection* selection;
	GtkTreeView * im_tree_view;
//	GladeXML* xml = global->main->xml;
	GtkBuilder *builder = global->main->builder;
	//TODO: get clean all field of list_store	
	
	im_tree_view = global->im_tree_view->treeview;
	selection = gtk_tree_view_get_selection(im_tree_view);


	if(FALSE == gtk_tree_selection_get_selected( selection, &model, &select_iter))
	{
		printf("get_tree_selection_get_select() return FALSE\n");
		return;
	}


	if(gtk_tree_model_get_iter_first(model,&iter))
	{
		do
		{
			gtk_list_store_set(GTK_LIST_STORE(model), &iter, IM_REC_DEFAULT_ON,FALSE, -1);
		} while( gtk_tree_model_iter_next(model, &iter));
	}
	else
	{

		printf("there is no Row,so return FALSE\n");
		return ;
	}

	gtk_list_store_set(GTK_LIST_STORE(model), &select_iter,
	IM_REC_DEFAULT_ON, TRUE,
	-1);
	
	if(1)
	{
	  gchar* im;
	  gchar* vstr;
	  gtk_tree_model_get (model ,&select_iter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
	  if(!g_oxim_conf_query_eng_name(vstr, &im)) g_printf("(%s:%d)[%s()] g_oxim_conf_query_eng_name(\"%s\",ret_im) return FALSE\n", __FILE__, __LINE__, __func__,vstr);
	  g_oxim_conf_set("SystemSetting","DefauleInputMethod",im,VT_STRING);
	  
	} //setting default im in g_oxim_conf_
	
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"delete_im_button"),FALSE);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "delete_im_button") ),FALSE);

} //default_button_clicked()




void global_button_clicked(GtkButton* default_button)
{
	printf("[Func %s() is invoked]start >>\n",__func__); 

//        GladeXML *xml;
        GtkBuilder *builder;
        GtkWidget* dialog;
	GtkTreeModel* model;
	GtkTreeIter iter;
	GtkTreeSelection* selection;
	GtkTreeView * im_tree_view;

	static globalsetting_dialog_data_t dialog_data={{FALSE,NULL},"Uni蝦米","嘸",TRUE,1};
//        xml = glade_xml_new (GLADE_FILEPATH, "globalsetting_dialog", NULL);
	GError* error = NULL;
	builder = gtk_builder_new();
	if( !gtk_builder_add_from_file( builder, GLADE_FILEPATH, &error ) )
	{
		g_warning( "Couldn't load builder file: %s", error->message );
		g_error_free(error);
	}

//	dialog_data.header.xml = xml;
//        dialog = glade_xml_get_widget (xml, "globalsetting_dialog");
//  	g_signal_connect( glade_xml_get_widget(xml,"globalsetting_dialog"), "show", 
//		G_CALLBACK(globalsetting_dialog_ctor),	(gpointer)(&dialog_data));
//  	g_signal_connect( glade_xml_get_widget(xml,"globalsetting_dialog"), "destroy", 
//		G_CALLBACK(globalsetting_dialog_dtor),	(gpointer)(&dialog_data));
//  	glade_xml_signal_autoconnect (xml);

	dialog_data.header.builder = builder;
	dialog = GTK_WIDGET( gtk_builder_get_object(builder, "globalsetting_dialog") );
	gtk_window_set_resizable( GTK_WINDOW(dialog), FALSE );
	g_signal_connect( GTK_WIDGET( gtk_builder_get_object(builder, "globalsetting_dialog") ), "show", 
		G_CALLBACK(globalsetting_dialog_ctor),	(gpointer)(&dialog_data));
	g_signal_connect( GTK_WIDGET( gtk_builder_get_object(builder, "globalsetting_dialog") ), "destroy", 
		G_CALLBACK(globalsetting_dialog_dtor),	(gpointer)(&dialog_data));
//  	glade_xml_signal_autoconnect (xml);
	gtk_builder_connect_signals( builder, NULL );



	//setting dialog_data via im_tree_view.	
	im_tree_view = global->im_tree_view->treeview;
	selection = gtk_tree_view_get_selection(im_tree_view);

	if(FALSE == gtk_tree_selection_get_selected( selection, &model, &iter))
	{
		printf("get_tree_selection_get_select() return FALSE\n");
		return;
	}

	gint combokey;
	gchar* text;
	
	gtk_tree_model_get (model, &iter, IM_REC_INPUT_METHOD_ALIAS_NAME, &text,-1);
	g_strlcpy(dialog_data.input_method_alias_name, text, -1);

	gtk_tree_model_get (model, &iter, IM_REC_INPUT_METHOD_NAME, &text,-1);
	g_strlcpy(dialog_data.input_method_name, text, -1);

	gtk_tree_model_get (model, &iter, IM_REC_FAST_KEY, &(combokey),-1);

	if(combokey<0 || combokey>9)
	{
		dialog_data.is_combo_used = FALSE;
		dialog_data.combo_number = 1;
	}
	else
	{
		dialog_data.is_combo_used = TRUE;
		dialog_data.combo_number = combokey;
	}


	gtk_dialog_run(GTK_DIALOG(dialog));   
//	gtk_widget_show_all( GTK_WIDGET(dialog) );
	gtk_widget_destroy(dialog);  
	if(dialog_data.header.is_dialog_press_accept==FALSE)
	{
		printf("[Func %s() is invoked]<< end\n",__func__);
		return;
	}
	
	if(1)
	{
	  GtkTreeIter treeiter;
	  gboolean repeat = FALSE;
	  if(dialog_data.is_combo_used  && gtk_tree_model_get_iter_first(model, &treeiter))
	  {
	    do
	    {
		
		gint fast_key_setting_value;
		gchar* text;
		gtk_tree_model_get(model, &treeiter, IM_REC_FAST_KEY, &fast_key_setting_value,-1);
		gtk_tree_model_get(model, &treeiter, IM_REC_INPUT_METHOD_NAME, &text,-1);
		if(g_utf8_str_equal(dialog_data.input_method_name,text))
		{
		  g_free(text);
		  continue;
		}
		g_free(text);
		if(fast_key_setting_value == dialog_data.combo_number)
		{
			repeat = TRUE;
			break;
		}
	    }while(gtk_tree_model_iter_next(model, &treeiter));
	  }
	  if(repeat)
	  {
	    dialog_data.is_combo_used = FALSE;
	    //TODO: show alert()
	    if(1)
	    {
		g_printf("\n%s\n%s\n", _("The key you choose had used by other Input-Method!\n"), _("Re-Select another key, please."));
		GtkWindow* parent_window = GTK_WINDOW( GTK_WIDGET( gtk_builder_get_object(builder, "window") ) );
		GtkMessageDialog* message_dialog = GTK_MESSAGE_DIALOG(gtk_message_dialog_new(
			parent_window, //parent window
			GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,//GtkDialogFlags
			GTK_MESSAGE_ERROR,//GtkMessageType
			GTK_BUTTONS_CLOSE,//GtkButtonsType
			"%s\n%s",_("The key you choose had used by other Input-Method!\n"), _("Re-Select another key, please.")
		));
		gtk_dialog_run(GTK_DIALOG(message_dialog));
		gtk_widget_destroy(GTK_WIDGET(message_dialog));
		return;
	    }
	  } //if(repeat)
	  
	}
	gtk_list_store_set (GTK_LIST_STORE(model), &iter,  
	IM_REC_INPUT_METHOD_ALIAS_NAME, dialog_data.input_method_alias_name,  
	IM_REC_FAST_KEY, (dialog_data.is_combo_used)?(dialog_data.combo_number):(-1),
	-1);


  if(1)
  {
	gboolean vbool;
	gint vint;
	gchar* vstr=NULL;

	gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
	gchar* im;
	//if(!g_oxim_conf_query_eng_name(vstr, &im)) continue;
	
	g_oxim_conf_query_eng_name(vstr, &im);
	//im have been g_utf8_str_assign(im, some string ) In above.
	gtk_tree_model_get (model ,&iter, IM_REC_TURN_ON, &vbool, -1);
	g_oxim_conf_set(im,"Circular",&vbool,VT_BOOL);
	
	gtk_tree_model_get (model ,&iter, IM_REC_DEFAULT_ON, &vbool, -1);
		
	if(vbool==TRUE)
	{
		g_printf("%s is default_on \n\n",im);
		g_oxim_conf_set("SystemSetting","DefauleInputMethod",im,VT_STRING);
	}

  	gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_ALIAS_NAME, &vstr, -1);
	g_oxim_conf_set(im,"AliasName",vstr, VT_STRING);

  	gtk_tree_model_get (model ,&iter, IM_REC_FAST_KEY, &vint, -1);
	if(vint==-1)
		g_oxim_conf_remove(im,"SetKey");
	else
		g_oxim_conf_set(im,"SetKey",&vint,VT_INT);

	g_free(im);
  }//add
	
	//The follow function is for 安裝輸入法->連線安裝 用的
	//gtk_tree_view_column_set_visible(gtk_tree_view_get_column(im_tree_view,0),FALSE);

	printf("[Func %s() is invoked]<< end\n",__func__);
} //global_button_clicked()




void property_button_clicked(GtkButton* property_button)
{
//g_debug("[[[%s]]]\n", gtk_button_get_label( GTK_BUTTON(property_button) ) );
        printf("[Func %s() is invoked]start >>\n",__func__);

        int property = 2;
//        GladeXML *xml;
        GtkBuilder *builder;
          GError* error = NULL;
        GtkWidget* dialog;
        GtkTreeModel* model;
        GtkTreeIter iter;
        GtkTreeSelection* selection;
        GtkTreeView * im_tree_view;
        im_tree_view = global->im_tree_view->treeview;
        selection = gtk_tree_view_get_selection(im_tree_view);
        if(FALSE == gtk_tree_selection_get_selected( selection, &model, &iter))
        {
                g_printf("(%s:%d)[%s]get_tree_selection_get_select() return FALSE\n",__FILE__,__LINE__,__func__);
                return;
        }

        gboolean *bb;
        gint *ii;
        gchar* ss;
        gchar* vstr=NULL;
        gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
        gchar* im=NULL;
        if(!g_oxim_conf_query_eng_name(vstr, &im))
        {
                g_printf("(%s:%d)[%s()] g_oxim_conf_query_eng_name fail\n", __FILE__, __LINE__, __func__);
                return;
        }

        static chewing_dialog_data_t chewing_dialog_data={{FALSE,NULL},CMK_STD_PH, CSM_1234, CCM_LOWER_CASE};

//      static gencin_dialog_data_t gencin_dialog_data;
//{{FALSE,NULL},"嘸蝦米",TRUE,TRUE,TRUE, TRUE,TRUE,TRUE, TRUE,TRUE, TRUE, "abc"}; 
         static gencin_dialog_data_t gencin_dialog_data;

         chewing_dialog_data.header.is_dialog_press_accept=FALSE;
         gencin_dialog_data.header.is_dialog_press_accept=FALSE;

#define GET(a,b,c,d) g_oxim_conf_get((a),(b),(c),(d))
        if(g_utf8_str_equal(im,"chewing"))
        {
                property = 1;
                chewing_dialog_data_t* r = &chewing_dialog_data;
                r->keymap = GET(im,"KeyMap",&ii,VT_INT) ? *ii :0;
                r->select = GET(im,"SelectionKeys",&ii,VT_INT) ? *ii :0;
                r->capslock=GET(im,"CapsLockMode",&ii,VT_INT) ? *ii :0;
        }
        else
        {
                static gencin_dialog_data_t deval;

                property = 2;
                gencin_dialog_data_t* r = &gencin_dialog_data;
                //g_utf8_str_assign(r->im_name,im);
                g_utf8_str_assign(r->input_method_name,(GET(im,"OriginalChineseName",&ss,VT_STRING))?ss:"中文輸入法名Error");
                r->is_on_auto_show_result_when_typeing = GET(im,"AutoCompose",&bb,VT_BOOL)?*bb:TRUE;
                r->is_start_up_general_used_character= GET(im,"WildEnable",&bb,VT_BOOL)?*bb:TRUE;
                r->is_to_press_space_to_clear_when_error=GET(im,"SpaceReset",&bb,VT_BOOL)?*bb:TRUE;

                r->is_auto_show_word_mode=GET(im,"AutoUpChar",&bb,VT_BOOL)?*bb:TRUE;
                r->is_output_word_when_type_space=GET(im,"SpaceAutoUp",&bb,VT_BOOL)?*bb:TRUE;
                r->is_shift_position_when_select=GET(im,"SelectKeyShift",&bb,VT_BOOL)?*bb:TRUE;

                r->is_auto_output_word_when_letter_full=GET(im,"AutoFullUp",&bb,VT_BOOL)?*bb:TRUE;
                r->is_continued_space_influent=GET(im,"SpaceIgnore",&bb,VT_BOOL)? (!(*bb)):FALSE;

                r->is_to_output_word_when_press_end=GET(im,"EndKey",&bb,VT_BOOL)?*bb:TRUE;

                g_utf8_str_assign(r->special_letter,(GET(im,"DisableSelectList",&ss,VT_STRING))?ss:"None");

                r->default_value = &deval;
                g_utf8_str_assign(deval.input_method_name, r->input_method_name);
                im_default_value_load(im);
                gchar *text;
                if(im_default_value_get_value("AutoCompose",&text))
                {
                        deval.is_on_auto_show_result_when_typeing = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_on_auto_show_result_when_typeing = FALSE;
                }

                if(im_default_value_get_value("WildEnable",&text))
                {
                        deval.is_start_up_general_used_character = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_start_up_general_used_character = FALSE;
                }

                if(im_default_value_get_value("SpaceReset", &text))
                {
                        deval.is_to_press_space_to_clear_when_error =  (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_to_press_space_to_clear_when_error = FALSE;
                }

                if(im_default_value_get_value("AutoUpChar", &text))
                {
                        deval.is_auto_show_word_mode = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_auto_show_word_mode = FALSE;
                }

                if(im_default_value_get_value("SpaceAutoUp", &text))
                {
                        deval.is_output_word_when_type_space = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_output_word_when_type_space = FALSE;
                }
               if(im_default_value_get_value("SelectKeyShift", &text))
                {
                        deval.is_shift_position_when_select =  (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_shift_position_when_select  = FALSE;
                }

                if(im_default_value_get_value("AutoFullUp", &text))
                {
                        deval.is_auto_output_word_when_letter_full = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_auto_output_word_when_letter_full = TRUE;
                }

                if(im_default_value_get_value("SpaceIgnore", &text))
                {
                        deval.is_continued_space_influent = (text[0]=='Y'?FALSE:TRUE);
                        g_free(text);
                }
                else
                {
                        deval.is_continued_space_influent = TRUE;
                }

                if(im_default_value_get_value("EndKey", &text))
                {
                        deval.is_to_output_word_when_press_end = (text[0]=='Y'?TRUE:FALSE);
                        g_free(text);
                }
                else
                {
                        deval.is_to_output_word_when_press_end = FALSE;
                }
               if(im_default_value_get_value("DisableSelectList", &text))
                {
                        g_utf8_str_assign(deval.special_letter, text);
                        g_free(text);
                }
                else
                {
                        g_utf8_str_assign(deval.special_letter, "None");
                }
        }
        //property = (g_utf8_str_equal(im,"chewing"))? 1 : 2;
#undef GET

        switch(property)
        {
        case 1: //chewing
//              xml = glade_xml_new (GLADE_FILEPATH, "chewing_dialog", NULL);
//              chewing_dialog_data.header.xml = xml;
//              dialog = glade_xml_get_widget (xml, "chewing_dialog");

                error = NULL;
                builder = gtk_builder_new();
                if( !gtk_builder_add_from_file(builder, GLADE_FILEPATH, &error) )
                {
                        g_warning( "Couldn't load builder file: %s", error->message );
                        g_error_free( error );
                }
                chewing_dialog_data.header.builder = builder;
                dialog = GTK_WIDGET( gtk_builder_get_object(builder, "chewing_dialog") );
                gtk_window_set_resizable( GTK_WINDOW(dialog), FALSE );


                g_signal_connect( dialog, "show",
                        G_CALLBACK(chewing_dialog_ctor),        (gpointer)(&chewing_dialog_data));
			
                g_signal_connect( dialog, "destroy",
                        G_CALLBACK(chewing_dialog_dtor),        (gpointer)(&chewing_dialog_data));

 
			
                
        break;
        case 2: //gencin
//              xml = glade_xml_new (GLADE_FILEPATH, "gencin_dialog", NULL);    
//              gencin_dialog_data.header.xml = xml;
//              dialog = glade_xml_get_widget (xml, "gencin_dialog");
//              g_signal_connect( glade_xml_get_widget(xml,"gencin_dialog"), "show", 
//                      G_CALLBACK(gencin_dialog_ctor), (gpointer)(&gencin_dialog_data));
//              g_signal_connect( glade_xml_get_widget(xml,"gencin_dialog"), "destroy", 
//                      G_CALLBACK(gencin_dialog_dtor), (gpointer)(&gencin_dialog_data));

                error = NULL;
                builder = gtk_builder_new();
                if( !gtk_builder_add_from_file(builder, GLADE_FILEPATH, &error) )
                {
                        g_warning( "Couldn't load builder file: %s", error->message );
                        g_error_free( error );
                }
                gencin_dialog_data.header.builder = builder;
                dialog = GTK_WIDGET( gtk_builder_get_object(builder, "gencin_dialog") );
                gtk_window_set_resizable( GTK_WINDOW(dialog), FALSE );

                g_signal_connect( GTK_WIDGET( gtk_builder_get_object(builder, "gencin_dialog") ), "show",
                        G_CALLBACK(gencin_dialog_ctor), (gpointer)(&gencin_dialog_data));
                g_signal_connect( GTK_WIDGET( gtk_builder_get_object(builder, "gencin_dialog") ), "destroy",
                        G_CALLBACK(gencin_dialog_dtor), (gpointer)(&gencin_dialog_data));


			   
//              g_signal_connect( GTK_WIDGET( gtk_builder_get_object(builder, "button7") ), "clicked", 
//                      G_CALLBACK(gencin_dialog_accept),       (gpointer)(&gencin_dialog_data));
        break;
        }

//      glade_xml_signal_autoconnect (xml);
       gtk_builder_connect_signals( builder, (gpointer)(&gencin_dialog_data) );
      gtk_dialog_run(GTK_DIALOG(dialog));  
//        gtk_widget_show_all( GTK_WIDGET(dialog) );
      gtk_widget_destroy(dialog);  

#define SET(a,b,c,d) g_oxim_conf_set((a),(b),(c),(d))
//g_debug("%d, %d, %d\n\n\n", property, chewing_dialog_data.header.is_dialog_press_accept, gencin_dialog_data.header.is_dialog_press_accept );

//	chewing_dialog_data.header.is_dialog_press_accept=TRUE;   
        if(property==1 && chewing_dialog_data.header.is_dialog_press_accept==TRUE)
        {
                chewing_dialog_data_t* r = &chewing_dialog_data;
                SET(im,"KeyMap",&(r->keymap),VT_INT);
                SET(im,"SelectionKeys",&(r->select),VT_INT);
                SET(im,"CapsLockMode",&(r->capslock),VT_INT);

        }
        else if(property==2 && gencin_dialog_data.header.is_dialog_press_accept==TRUE)
        {

                gencin_dialog_data_t* r = &gencin_dialog_data;
                SET(im,"AutoCompose",&(r->is_on_auto_show_result_when_typeing),VT_BOOL);
                SET(im,"WildEnable",&(r->is_start_up_general_used_character),VT_BOOL);
                SET(im,"SpaceReset",&(r->is_to_press_space_to_clear_when_error),VT_BOOL);

                SET(im,"AutoUpChar",&(r->is_auto_show_word_mode),VT_BOOL);
                SET(im,"SpaceAutoUp",&(r->is_output_word_when_type_space),VT_BOOL);
                SET(im,"SelectKeyShift",&(r->is_shift_position_when_select),VT_BOOL);

                SET(im,"AutoFullUp",&(r->is_auto_output_word_when_letter_full),VT_BOOL);
                SET(im,"SpaceIgnore",(r->is_continued_space_influent)?pFALSE():pTRUE(),VT_BOOL);

                SET(im,"EndKey",&(r->is_to_output_word_when_press_end),VT_BOOL);

                if(r->special_letter==NULL)
                        g_utf8_str_assign(vstr,"None");
                else
                        if(r->special_letter[0]=='\0')
                                g_utf8_str_assign(vstr,"None");
                        else
                                g_utf8_str_assign(vstr,r->special_letter);
                SET(im,"DisableSelectList",r->special_letter,VT_STRING);
        }

#undef SET
        if(im!=NULL)g_free(im);
g_debug("%d\n", property);
        printf("[Func %s() is invoked]<< end\n",__func__);

} //property_button_clicked()








void add_im_button_clicked(GtkButton* add_im_button)
{
	printf("[Func %s() is invoked]start >>\n",__func__); 

//        GladeXML *xml;
        GtkBuilder *builder;
        GtkWidget* dialog;
	static installim_dialog_data_t installim_dialog_data = {{FALSE,NULL},""};
	
//        xml = glade_xml_new (GLADE_FILEPATH, "installim_dialog", NULL);
//	installim_dialog_data.header.xml = xml;
//        dialog = glade_xml_get_widget (xml, "installim_dialog");

        GError* error = NULL;
	  builder = gtk_builder_new();
	  if( !gtk_builder_add_from_file(builder, GLADE_FILEPATH, &error) )
	   {
		g_warning( "Couldn't load builder file: %s", error->message );
		g_error_free( error );
	   }
	  installim_dialog_data.header.builder = builder;
	  dialog = GTK_WIDGET( gtk_builder_get_object(builder, "installim_dialog") );
	  gtk_window_set_resizable( GTK_WINDOW(dialog), FALSE );

	
	g_signal_connect( dialog, "show", 
		G_CALLBACK(installim_dialog_ctor),(gpointer)(&installim_dialog_data));
	g_signal_connect_after( dialog, "destroy", 
		G_CALLBACK(installim_dialog_dtor),(gpointer)(&installim_dialog_data));
//  	glade_xml_signal_autoconnect (xml);
	gtk_builder_connect_signals( builder, NULL );
//	gtk_dialog_run(GTK_DIALOG(dialog));
	gtk_widget_show_all( GTK_WIDGET(dialog) );
//	gtk_widget_destroy(dialog); ----------------------------------------跳視窗元兇

	printf("[Func %s() is invoked]<< end\n",__func__);
} //add_im_button_clicked()


void delete_im_button_clicked(GtkButton* delete_im_button)
{
	printf("[Func %s() is invoked]\n",__func__);
  if(1) //delete the selected im in g_oxim_conf
  {
    GtkTreeView* treeview = global->im_tree_view->treeview;
    GtkTreeSelection* selection = gtk_tree_view_get_selection(treeview);
    //GtkListStore* list_store=NULL;
    //GtkTreeModel* model=NULL;
    GtkListStore* list_store=global->im_tree_view->list_store;
    GtkTreeModel* model=GTK_TREE_MODEL(list_store);
    GtkTreeIter iter;

    if(gtk_tree_selection_get_selected(selection, &model, &iter))
    {
	
	list_store = GTK_LIST_STORE(model);
	gchar *text=NULL;
	gchar *im=NULL;
	gtk_tree_model_get(model, &iter, IM_REC_INPUT_METHOD_NAME, &text, -1);
	
	g_oxim_conf_query_eng_name(text, &im);
	g_oxim_conf_remove_imtable(im);
	g_free(im);
    }
    else
    {
	g_printf("(%s:%d)[%s()] gtk_tree_selection_get_selected failed\n", __FILE__, __LINE__, __func__);
    }
  }//if(1) //delete the selected im in g_oxim_conf
	
	if(im_tree_view(main_mine, OP_REMOVE_SELECTION, NULL)->fail)
		g_printf("(%s:%d)[%s()]im_tree_view remove selection fail\n",__FILE__,__LINE__,__func__);

} //delete_im_button_clicked()




im_tree_view_ref_t *im_tree_view(main_ref_t* me, operation_t op,gpointer arg)
{

	printf("[Func %s() is invoked]\n",__func__);
	//'me' store caller's data and mine store callee's data, which store callee executing state in mine.fail
	static im_tree_view_ref_t mine={NULL,FALSE,FALSE,NULL,NULL};
	//ref, has_init, fail
	//treeview, list_store

	//GtkTreeIter treeiter;

	mine.fail=FALSE;
	switch(op)
	{
	case OP_INIT: 
	  if(mine.has_init)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		mine.ref=me;
		im_tree_view_init(&mine,arg);
		if(mine.fail==FALSE) mine.has_init = TRUE;
	  }
	  break;
	case OP_GET_DATA:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		
	  }
	  break;
	case OP_REMOVE_SELECTION:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		im_tree_view_remove_selection(&mine,arg);	
	  }
	  break;
  	case OP_SAVE_FILE:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		im_tree_view_save_file(&mine,arg);
	  }
	  break;
	default:
		mine.fail=TRUE;
	  break;
	} //switch(op)
	return &mine;
} //im_tree_view()


icon_text_view_ref_t *icon_text_view(main_ref_t* me, operation_t op, gpointer arg)
{
  	printf("[Func %s() is invoked]\n",__func__);
	//'me' store caller's data and mine store callee's data, which store callee executing state in mine.fail
	static icon_text_view_ref_t mine ={NULL,FALSE,FALSE,NULL,NULL};	 
	//ref, has_init, fail
	//textview, textview_buffer

	mine.fail=FALSE;
	switch(op)
	{
	case OP_INIT:
	  if(mine.has_init==TRUE)mine.fail=TRUE; //precondition 1 check
	  if(!mine.fail)
	  {
		mine.ref = me;
		icon_text_view_init(&mine,arg);
		if(mine.fail==FALSE) mine.has_init = TRUE;
	  }
	  break;
	case OP_GET_DATA:
	  if(mine.has_init==FALSE)mine.fail=TRUE; //precondition 1 check
	  if(!mine.fail)
	  {
	  }
	  break;
	default:
	  mine.fail=TRUE;
	} //switch(op)
	return &mine;
} //icon_text_view()



phase_tree_view_ref_t* phase_tree_view(main_ref_t* me,operation_t op, gpointer arg)
{


  printf("[Func %s() is invoked]\n",__func__);
	//'me' store caller's data and mine store callee's data, which store callee executing state in mine.fail
	static phase_tree_view_ref_t mine={NULL,FALSE,FALSE,NULL,NULL};
	//ref, has_init, fail
	//treeview, list_store

	mine.fail=FALSE;
	switch(op)
	{
	case OP_INIT: 
	  if(mine.has_init)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		//GtkTreeIter treeiter;
		mine.ref=me;		
		phase_tree_view_init(&mine,arg);
		if(mine.fail==FALSE) mine.has_init = TRUE;
	  }
	  break;

	case OP_GET_DATA:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
	  }
	  break;
	default:
		mine.fail=TRUE;
	  break;
	} //switch(op)
	return &mine;
} //phase_tree_view()



void icon_text_view_init(icon_text_view_ref_t* me, gpointer arg)
{

  printf("[Func %s() is invoked]\n",__func__);
	GtkTextIter line;

//	me->textview = GTK_TEXT_VIEW(glade_xml_get_widget(me->ref->xml, "icon_textview"));
	me->textview = GTK_TEXT_VIEW( GTK_WIDGET( gtk_builder_get_object(me->ref->builder, "icon_textview") ) );
	me->textview_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(me->textview));

	gtk_text_buffer_set_text( me->textview_buffer," \n\n\n\n\n\n",-1);
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 1); 
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON1_FILEPATH,NULL));
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 2);
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON2_FILEPATH,NULL));
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 3);
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON3_FILEPATH,NULL));
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 4);
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON4_FILEPATH,NULL));
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 5);
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON5_FILEPATH,NULL));
	gtk_text_buffer_get_iter_at_line( me->textview_buffer, &line, 6);
	gtk_text_buffer_insert_pixbuf( me->textview_buffer, &line,  gdk_pixbuf_new_from_file(TEXTVIEW_ICON6_FILEPATH,NULL));

} //icon_text_view_init()




void phase_tree_view_init(phase_tree_view_ref_t* mine, gpointer arg)
{
  printf("[Func %s() is invoked]\n",__func__);
	GtkTreeIter treeiter;
//	mine->treeview = GTK_TREE_VIEW(glade_xml_get_widget(mine->ref->xml,"phase_treeview"));
	mine->treeview = GTK_TREE_VIEW( GTK_WIDGET( gtk_builder_get_object(mine->ref->builder, "phase_treeview") ) );

#if 0
	gtk_tree_view_append_column(mine->treeview, 
	  gtk_tree_view_column_new_with_attributes("   ", 
	    gtk_cell_renderer_text_new(),
	    "text", 0, NULL));
#else
	if(1)
	{
	  GtkCellRenderer *renderer = NULL;
	  GtkTreeViewColumn* column = NULL;
	  column = gtk_tree_view_column_new();
	  renderer = gtk_cell_renderer_text_new();
	  gtk_tree_view_column_set_title(column, "   ");
	  gtk_tree_view_column_pack_start(column, renderer, TRUE);
	  gtk_tree_view_column_set_cell_data_func(column, renderer, phrase_cell_data_func, NULL, NULL);
	  gtk_tree_view_column_add_attribute(column, renderer, "text", 0);
	  gtk_tree_view_append_column(mine->treeview, column);
	}
#endif 



	GtkCellRenderer *renderer;
	//GtkTreeViewColumn *column;
	renderer = gtk_cell_renderer_text_new();
	g_object_set(renderer, "editable", TRUE, "editable-set",TRUE,NULL);
	g_signal_connect(	G_OBJECT(renderer), "edited",
				G_CALLBACK(phase_tree_view_cell_edited),(gpointer) mine->treeview );
	gtk_tree_view_append_column(mine->treeview, 
	  gtk_tree_view_column_new_with_attributes("Alt + Shift", 
	    renderer,
	    "text", 1, NULL));


	mine->list_store = gtk_list_store_new( 2, G_TYPE_STRING, G_TYPE_STRING);
	//gtk_list_store_append( mine->list_store, &treeiter);
	gint idx;

	phrase_reload(&phase_strlist, &phase_strlist_size);
	
	for(idx=0;idx<phase_strlist_size ;idx++)
	{	
		gtk_list_store_append(mine->list_store, &treeiter);
		gtk_list_store_set(mine->list_store, &treeiter, 0,phase_strlist[idx][0], 1,phase_strlist[idx][1],-1);
		//gtk_list_store_append(mine->list_store, &treeiter);
	} 
	gtk_tree_view_set_model( mine->treeview, GTK_TREE_MODEL(mine->list_store));
	//g_object_unref( phase_list_store);
} //phase_tree_view_init()


void im_tree_view_save_file(im_tree_view_ref_t* mine, gpointer arg)
{
	g_printf("[%s() is invoked]\n",__func__);
	GtkTreeIter iter;
	GtkTreeModel *model = GTK_TREE_MODEL(mine->list_store);

	gboolean vbool;
	gint vint;
	gchar* vstr=NULL;
  if(0)
  {
	if(gtk_tree_model_get_iter_first(model, &iter))
	{
	  do{
		//static gchar im[256];
		//TODO: find the eng_name and store it into im
		gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
		gchar* im;
		if(!g_oxim_conf_query_eng_name(vstr, &im)) continue;
		//im have been g_utf8_str_assign(im, some string ) In above.

  		gtk_tree_model_get (model ,&iter, IM_REC_TURN_ON, &vbool, -1);
		g_oxim_conf_set(im,"Circular",&vbool,VT_BOOL);
		
		
  		gtk_tree_model_get (model ,&iter, IM_REC_DEFAULT_ON, &vbool, -1);
		
		if(vbool==TRUE)
		{
			g_printf("%s is default_on \n\n",im);
			 g_oxim_conf_set("SystemSetting","DefauleInputMethod",im,VT_STRING);
		}

  		gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_ALIAS_NAME, &vstr, -1);
		g_oxim_conf_set(im,"AliasName",vstr, VT_STRING);

  		gtk_tree_model_get (model ,&iter, IM_REC_FAST_KEY, &vint, -1);
		if(vint==-1)
			g_oxim_conf_remove(im,"SetKey");
		else
			g_oxim_conf_set(im,"SetKey",&vint,VT_INT);

		g_free(im);

  		//gtk_tree_model_get (model ,iter, IM_REC_FAST_KEY, &vint, -1);
	  }while(gtk_tree_model_iter_next(model, &iter));
	}
  } //if(0)milochen comment 



	g_oxim_conf_update();
} //im_tree_view_save_file()



void im_tree_view_init(im_tree_view_ref_t* mine, gpointer arg)
{
	g_printf("[%s() is invoked]\n",__func__);
	GtkTreeIter treeiter;
	GtkCellRenderer *renderer;
	GtkTreeViewColumn *column;
#if 1
	if(mine->list_store==NULL)
		gtk_list_store_clear(mine->list_store);
#endif //milochen add
	mine->list_store = gtk_list_store_new(6,
	G_TYPE_BOOLEAN, //model_idx==0 -> for IM treeview 輪換
	G_TYPE_BOOLEAN, //GDK_TYPE_PIXBUF,//model_idx==1 ->是否為 預設輸入法
	G_TYPE_STRING, //model_idx==2 -> 輸入法名稱 
	G_TYPE_STRING,	//model_idx==3 -> for IM treeview 輸入法名稱別名
	G_TYPE_INT,  //model_idx==4 -> for IM treeview 快速鍵 , 若-1 則代表沒有快速鍵
	G_TYPE_BOOLEAN, //model_idx==5 -> for IM treeview ==
	-1);

//	mine->treeview = GTK_TREE_VIEW(glade_xml_get_widget(mine->ref->xml, "IM_treeview"));	
	mine->treeview = GTK_TREE_VIEW( GTK_WIDGET( gtk_builder_get_object(mine->ref->builder, "IM_treeview") ) );	
	GtkTreeModel *model = GTK_TREE_MODEL(mine->list_store);


	typedef struct
	{
		gboolean turn_on; //0 輪換
		gboolean  default_on; //1 預設
		gchar input_method_name[100]; //2 輸入法名稱(hide)
		gchar input_method_alias_name[100];//3 輸入法名稱之別名 (show for treeview of 輸入法名稱
		gint  fast_key;//4 快速鍵
		gboolean im_buildin;// ==
	}im_tree_view_record_t;

	gint imtable_num=0;
	gint idx=0;

#if 1
	static im_tree_view_record_t recs[100];
	static gchar* imtables[100];

	if(TRUE == g_oxim_conf_first_imtable(&imtables[0]))
	{
		//g_printf(imtables[0]);

		gboolean *bb;
		gint *ii;
		gchar *ss;
		gchar empty_str[]="";
		//gchar empty_alias_name[]="empty_alias";
		gchar empty_chi_name[]="empty_chi";
		do{
			
			im_tree_view_record_t* r = &recs[idx];
			
			g_printf("\nidx=%d\n",idx);
			gchar* im = imtables[idx];
			g_printf("\nim=%s\n",im);
#define GET(a,b,c,d) g_oxim_conf_get((a),(b),(c),(d))
			//set turn_on by Circular in oxim.conf
			r->turn_on =  (GET(im,"Circular",&bb,VT_BOOL)) ? *bb : FALSE;

			//set default_on according to  SystemSetting.DefauleInputMethod
			GET("SystemSetting","DefauleInputMethod",&ss,VT_STRING);
			r->default_on = g_utf8_str_equal(ss,im);

			//set input_method_name by OriginalChineseName in oxim.conf
			g_utf8_str_assign(r->input_method_name,(GET(im,"OriginalChineseName",&ss,VT_STRING))?ss:empty_chi_name);

			//set input_method_alias_name by AliasName in oxim.conf
			g_utf8_str_assign(r->input_method_alias_name,(GET(im,"AliasName",&ss,VT_STRING)) ? ss:empty_str);
			
			//set fast_key according to SetKey of oxim.conf
			r->fast_key = (GET(im,"SetKey",&ii, VT_INT))? *ii :-1;
			
			//set im_buildin if it is buildin InputMethod
			r->im_buildin=(	g_utf8_str_equal(im,"cnsphone")||g_utf8_str_equal(im,"cnscj")||
 					g_utf8_str_equal(im,"chewing")||g_utf8_str_equal(im,"unicode")) ? TRUE : FALSE;	
#undef GET
			idx++;
		}while(TRUE==g_oxim_conf_next_imtable(&(imtables[idx])));
	}
	imtable_num = idx;





#else	
	imtable_num=8;
	static im_tree_view_record_t recs[] = 
	{

		{ FALSE, FALSE,"四角五碼","",-1,FALSE},
		{ FALSE, FALSE,"行列30","",-1,FALSE},
		{ TRUE, FALSE,"四角號碼","",-1,FALSE},
		{ TRUE, TRUE ,"Uni蝦米","嘸蝦米",-1,FALSE},
		{ FALSE, FALSE, "中標注音","中標注音", -1,TRUE},
		{ FALSE, FALSE,"中標倉頡","中標倉頡",-1,TRUE},
		{ FALSE, FALSE,"新酷音","新酷音",7,TRUE },
		{ FALSE, FALSE,"萬國碼","萬國碼",0,TRUE },
	}; //im_tree_view_record_t
#endif 
	for(idx=0; idx<imtable_num; idx++)
	{
		gtk_list_store_append(mine->list_store, &treeiter);
		gtk_list_store_set(mine->list_store, &treeiter, 
			IM_REC_TURN_ON,			recs[idx].turn_on, 
			IM_REC_DEFAULT_ON,		recs[idx].default_on, 
			IM_REC_INPUT_METHOD_NAME,	recs[idx].input_method_name, 
			IM_REC_INPUT_METHOD_ALIAS_NAME,	recs[idx].input_method_alias_name, 
			IM_REC_FAST_KEY,		recs[idx].fast_key, 
			IM_REC_IM_BUILDIN,		recs[idx].im_buildin, 		
		 -1);

	} // for idx


	//set tree view

#if 1

	//set column 1
	renderer = gtk_cell_renderer_toggle_new();
	g_signal_connect ( renderer, "toggled",
			G_CALLBACK( fixed_toggled), model);
	gtk_tree_view_append_column(mine->treeview, 
	//  gtk_tree_view_column_new_with_attributes("輪換",
	  gtk_tree_view_column_new_with_attributes(_("circular"),
	    renderer,
	    "active", 0, NULL));	

#endif 
#if 1
	//set column 2 DEFAULT_ON + INPUT_METHOD_ALIAS_NAME
	column = gtk_tree_view_column_new();
	//gtk_tree_view_column_set_title(column, "輸入法名稱");
	gtk_tree_view_column_set_title(column, _("Input Method"));
	renderer = gtk_cell_renderer_pixbuf_new();

	gtk_tree_view_column_pack_start(column, renderer, TRUE);
	gtk_tree_view_column_set_cell_data_func(column, renderer, apply_pixbuf_cell_data_func, NULL, NULL);
	gtk_tree_view_column_set_attributes(column, renderer, "stock-id", IM_REC_DEFAULT_ON, NULL);

	renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_column_pack_start(column, renderer, TRUE);
	gtk_tree_view_column_set_cell_data_func(column, renderer, input_method_alias_name_cell_data_func, NULL, NULL);
	gtk_tree_view_column_set_attributes(column, renderer, "text", IM_REC_INPUT_METHOD_ALIAS_NAME, NULL);

	gtk_tree_view_append_column(mine->treeview, column);

#endif 
#if 1

	//set column 3 
	renderer = gtk_cell_renderer_text_new();
	//column = gtk_tree_view_column_new_with_attributes("快速鍵", renderer, "text", IM_REC_FAST_KEY, NULL);
	column = gtk_tree_view_column_new_with_attributes(_("Hotkey"), renderer, "text", IM_REC_FAST_KEY, NULL);
	gtk_tree_view_append_column(mine->treeview, column);
	gtk_tree_view_column_set_cell_data_func(column, renderer, fast_key_cell_data_func, NULL, NULL);

	//set column 4

#endif 
#if 1

	renderer = gtk_cell_renderer_text_new();
	column = gtk_tree_view_column_new_with_attributes("==", renderer, "text", IM_REC_IM_BUILDIN, NULL);
	gtk_tree_view_append_column(mine->treeview, column);
	gtk_tree_view_column_set_cell_data_func(column, renderer, im_buildin_cell_data_func, NULL, NULL);

#endif 



	gtk_tree_view_set_model( mine->treeview,model);

//	g_signal_connect( glade_xml_get_widget(mine->ref->xml, "IM_treeview"), "cursor-changed", 
//		G_CALLBACK(im_tree_view_cursor_changed),	(gpointer)(mine));
	g_signal_connect( GTK_WIDGET( gtk_builder_get_object(mine->ref->builder, "IM_treeview") ), "cursor-changed", 
		G_CALLBACK(im_tree_view_cursor_changed),	(gpointer)(mine));

} //im_tree_view_init()



void
phrase_cell_data_func (GtkTreeViewColumn *column,
                         GtkCellRenderer *renderer,
                         GtkTreeModel *model,
                         GtkTreeIter *iter,
                         gpointer data)
{
  
  static gint color_map_table[256];
  static gint* cmt=NULL;
  static gint color_mod=2;
  static gchar color_idx_rgb[][8]={"#eeeeaa","#eeeeee"};
  if(cmt==NULL)
  {
    cmt = color_map_table;
    gint idx=0;
    gint color_circular=0;
    for(idx=0;idx<256;idx++)cmt[idx]=-1;
    if(1)
    {
	GtkTreeIter titer;
	if(gtk_tree_model_get_iter_first(model, &titer))
	{
	  do{
	    gchar* text;
	    gtk_tree_model_get(model, &titer, 0, &text, -1);
	    cmt[(gint)text[0]]=color_circular;
	    g_free(text);
	    color_circular+=1;
	    color_circular%=color_mod;
	  }while(gtk_tree_model_iter_next(model, &titer));
	}	
    }
  } //if(cmd==NULL)
  if(1) //to set background color and it's text
  {
    gchar* text;
    gchar* show_out;
    gtk_tree_model_get(model, iter, 0, &text, -1);
    gint color_idx = cmt[(gint)text[0]];
    show_out = g_strdup_printf("　%s　",text);

    g_object_set(renderer, 
		"text",			show_out, 
		"background", 		(color_idx<0)?("#ffffff"):(color_idx_rgb[color_idx]), 
		"background-set", 	TRUE,
    		NULL);

    g_free(show_out);
    g_free(text);

  } //if(1)

} //phrase_cell_data_func()


void
fast_key_cell_data_func (GtkTreeViewColumn *column,
                         GtkCellRenderer *renderer,
                         GtkTreeModel *model,
                         GtkTreeIter *iter,
                         gpointer data)
{
  gint fast_key;
  gtk_tree_model_get (model ,iter, IM_REC_FAST_KEY, &fast_key, -1);
  static gchar ctrl_alt_str[] = "Ctrl + Alt +  ";
//  static gchar non_str[] = "無";
  static gchar *non_str=NULL;
  if(non_str==NULL) non_str = g_strdup_printf("%s", _("None"));
  //static gchar non_str[] = _("None");
  //static gchar non_str[] = _("None");
  if(fast_key<0 || fast_key>9)
  {	
  	g_object_set (renderer, "text", non_str, NULL);
  }
  else
  {
  	ctrl_alt_str[13] = (gchar)('0' + fast_key);
	g_object_set (renderer, "text", ctrl_alt_str, NULL); 
  }

} //fast_key_cell_data_func()

void
im_buildin_cell_data_func (GtkTreeViewColumn *column,
                           GtkCellRenderer *renderer,
                           GtkTreeModel *model,
                           GtkTreeIter *iter,
                           gpointer data)
{
 // gchar *text;
  gboolean im_buildin;
  gtk_tree_model_get (model ,iter, IM_REC_IM_BUILDIN, &im_buildin, -1);
//  static gchar buildin_str[] = "<內建>";
//  static gchar buildin_str[] = _("<built-in>");
  static gchar* buildin_str = NULL;
  if(buildin_str==NULL) buildin_str = g_strdup_printf("%s", _("<built-in>"));
  static gchar non_buildin_str[] = "    ";

  if(im_buildin == TRUE)
  {
  	g_object_set (renderer, "text", buildin_str, NULL);
  }
  else
  {
	g_object_set (renderer, "text", non_buildin_str, NULL); 
  }

} //im_buildin_cell_data_func()

void
apply_pixbuf_cell_data_func (GtkTreeViewColumn *column,
                           GtkCellRenderer *renderer,
                           GtkTreeModel *model,
                           GtkTreeIter *iter,
                           gpointer data)
{
  gboolean toggle;
  gtk_tree_model_get (model ,iter, IM_REC_DEFAULT_ON, &toggle, -1);

  if(toggle == TRUE)
  {
  	g_object_set (renderer, "stock-id", GTK_STOCK_APPLY, NULL);
  }
  else
  {
#ifdef GTK_STOCK_DISCARD
	g_object_set (renderer, "stock-id", GTK_STOCK_DISCARD, NULL); 
#else
	g_object_set (renderer, "stock-id", NULL, NULL); 
#endif //GTK_STOCK_DISCARD
  }

} //im_buildin_cell_data_func()

void
input_method_alias_name_cell_data_func (GtkTreeViewColumn *column,
                           GtkCellRenderer *renderer,
                           GtkTreeModel *model,
                           GtkTreeIter *iter,
                           gpointer data)
{

  gchar *text;
  gtk_tree_model_get (model ,iter, IM_REC_INPUT_METHOD_ALIAS_NAME, &text, -1);
  if(text[0]==0 || text==NULL)
  {
	g_free(text);
  	gtk_tree_model_get (model ,iter, IM_REC_INPUT_METHOD_NAME, &text, -1);
  }
  g_object_set(renderer, "text",text,NULL);
  g_free(text);

} //apply_pixbuf_cell_data_func()


void im_tree_view_remove_selection(im_tree_view_ref_t* mine, gpointer arg)
{
	
	printf("[%s() is invoked]\n",__func__);
	GtkTreeSelection* selection = gtk_tree_view_get_selection(mine->treeview);
	GtkTreeModel* get_model;
	GtkTreeIter treeiter;
	gchar* vstr=NULL;
	//gchar* im=NULL;
	if(FALSE == gtk_tree_selection_get_selected( selection, &get_model, &treeiter))
	{
		g_printf("(%s:%d)[%s] get_tree_selection_get_select() return FALSE\n",__FILE__,__LINE__,__func__);
		mine->fail = TRUE;
		 return;
	}
	if(get_model != (GtkTreeModel*)mine->list_store)
	{
		g_printf("(%s:%d)[%s] get_model is incorrect\n",__FILE__, __LINE__, __func__);
		mine->fail = TRUE;
		return;
	}


//	GladeXML* xml = mine->ref->xml;
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"delete_im_button"),FALSE);
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"global_button"),FALSE);
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"property_button"),FALSE);
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"default_button"),FALSE);

	GtkBuilder *builder = mine->ref->builder;
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "delete_im_button") ),FALSE);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "global_button") ),FALSE);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "property_button") ),FALSE);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "default_button") ),FALSE);


#if 1	
	gtk_tree_model_get(get_model, &treeiter, IM_REC_INPUT_METHOD_NAME,&vstr,-1);
	g_printf("(%s:%d)[%s] vstr = %s\n",__FILE__, __LINE__, __func__, vstr);

#endif //if 0


	if(!gtk_list_store_remove(mine->list_store, &treeiter))
	{
		printf("\n%d\n",sizeof(treeiter));
		g_printf("(%s:%d)[%s()] gtk_list_store_remove() error\n",__FILE__, __LINE__, __func__);
		mine->fail = TRUE;
		//return;
	}


	//g_oxim_conf_remove_imtable("4corner5");
	gchar* fm2;

	if(!g_oxim_conf_query_eng_name(vstr, &fm2))
	{
		g_printf("(%s:%d)[%s]\n", __FILE__, __LINE__, __func__);
		return;
	}
	else
	{
		g_oxim_conf_remove_imtable(fm2);	
		g_printf("(%s:%d)[%s] removed im=%s\n", __FILE__, __LINE__, __func__,fm2);

		if(1) //kill file fm2.tab in /tmp/.oxim/tables/~/*.tab if exist
		{
		  static gchar fp[100];
  		  g_sprintf(fp, "%s/.oxim/tables/%s/%s.tab",g_get_usertmp_dir(), g_get_user_name(),fm2);
		  if(g_file_test(fp, G_FILE_TEST_EXISTS))
		  {
		    static gchar cmd[120];
		    g_printf("rm -f %s",fp);
		    system(cmd);
		  }
		} //if(1) //kill file fm2.tab in /tmp/.oxim/tables/~/*.tab if exist

		g_free(fm2);
	}

	g_printf("[%s() is invoked END]\n",__func__);

} //im_tree_view_remove_selection()



void im_tree_view_cursor_changed(GtkTreeView* treeview, im_tree_view_ref_t* mine)
{
	printf("[Func %s() is invoked]\n",__func__);
	GtkWidget *menu = right_popup_menu;
	right_popup_menu =NULL;

	//get what selection

//	GladeXML* xml = mine->ref->xml;
	GtkBuilder *builder = mine->ref->builder;

	//GtkWidget* delete_im_button = glade_xml_get_widget(xml,"window");
/*
	GtkWidget* property_button = glade_xml_get_widget(xml,"property_button");
	GtkWidget* global_button = glade_xml_get_widget(xml,"global_button");
	GtkWidget* default_button = glade_xml_get_widget(xml,"default_button");
*/

	GtkTreeSelection* selection = gtk_tree_view_get_selection(treeview);
	GtkTreeModel* model;
	GtkTreeIter iter;
	if(FALSE == gtk_tree_selection_get_selected( selection, &model, &iter))
	{
		printf("get_tree_selection_get_select() return FALSE\n");
		 return;
	}

		printf("get_tree_selection_get_select() return TRUE\n");
	gboolean isTrueA=TRUE;
	gboolean isTrueB=TRUE;
	gchar* text;

//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"global_button"),TRUE);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "global_button") ),TRUE);
	gtk_widget_set_sensitive(treeview_popup_item_gen, TRUE);
	gtk_tree_model_get (model ,&iter, IM_REC_IM_BUILDIN, &isTrueA, -1);

	//gtk_widget_set_sensitive(glade_xml_get_widget(xml,"delete_im_button"),!isTrueA);
	gtk_tree_model_get (model ,&iter, IM_REC_DEFAULT_ON, &isTrueB, -1);
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"default_button"), !isTrueB);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "default_button") ), !isTrueB);
	gtk_widget_set_sensitive(treeview_popup_item_def, !isTrueB);
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"delete_im_button"),!isTrueB && !isTrueA);
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "delete_im_button") ),!isTrueB && !isTrueA);
	gtk_widget_set_sensitive(treeview_popup_item_rem,!isTrueB && !isTrueA);
	gtk_tree_model_get (model ,&iter, IM_REC_INPUT_METHOD_NAME, &text, -1);	
//	gtk_widget_set_sensitive(glade_xml_get_widget(xml,"property_button"), g_strcasecmp(text, "萬國碼"));
	gtk_widget_set_sensitive( GTK_WIDGET( gtk_builder_get_object(builder, "property_button") ), g_strcasecmp(text, "萬國碼"));
	gtk_widget_set_sensitive(treeview_popup_item_pro, g_strcasecmp(text, "萬國碼"));
	
	if(menu)
	{
  	  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 3, gtk_get_current_event_time());
	}

} //im_tree_view_cursor_changed()



void phase_tree_view_cell_edited (GtkCellRendererText *renderer, gchar *path, gchar *new_text, GtkTreeView *treeview)
{
	GtkTreeIter iter;
	GtkTreeModel *model;
	
	//if(g_ascii_strcasecmp(new_text, "") != 0)
	//{
		model = gtk_tree_view_get_model(treeview);
		if(gtk_tree_model_get_iter_from_string(model, &iter, path))
		{
		  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1, new_text, -1);
		  gchar* text=NULL;
		  gtk_tree_model_get(model, &iter, 0, &text, -1);
		  gint idx;
		  for(idx=0;idx<phase_strlist_size;idx++)
		  {
		    if(g_utf8_str_equal(phase_strlist[idx][0], text))
		    {
			g_free(phase_strlist[idx][1]);
			phase_strlist[idx][1]=g_strdup(new_text);
			break;
		    }
		  }
		  g_free(text);
		}
	//}	
} //cell_edited()




mrrrsites_tree_view_ref_t* mrrrsites_tree_view(main_ref_t* me, operation_t op,gpointer arg )
{
	g_printf("[Func %s() is invoked]\n",__func__);
	//'me' store caller's data and mine store callee's data, which store callee executing state in mine.fail
	
	static mrrrsites_tree_view_ref_t mine={NULL,FALSE,FALSE,NULL,NULL};
	
	mine.fail=TRUE;
	switch(op)
	{
	case OP_INIT: 
	  if(mine.has_init)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		mine.ref=me;
		mrrrsites_tree_view_init(&mine,arg);
		if(mine.fail==FALSE) mine.has_init = TRUE;
	  }
	  break;
	case OP_GET_DATA:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		
	  }
	  break;
	case OP_CONNECT_SELECTION:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		mrrrsites_tree_view_connect_selection(&mine,arg);
	  }
	  break;

	default:
		mine.fail=TRUE;
	  break;
	} //switch(op)
	return &mine;	
}  //mrrrsites_tree_view()

mrrrcontents_tree_view_ref_t* mrrrcontents_tree_view(main_ref_t* me, operation_t op,gpointer arg )
{
	g_printf("[Func %s() is invoked]\n",__func__);
	//'me' store caller's data and mine store callee's data, which store callee executing state in mine.fail
	
	static mrrrcontents_tree_view_ref_t mine={NULL,FALSE,FALSE,NULL,NULL};
	
	mine.fail=TRUE;
	switch(op)
	{
	case OP_INIT: 
	  if(mine.has_init)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		mine.ref=me;
		mrrrcontents_tree_view_init(&mine,arg);
		if(mine.fail==FALSE) mine.has_init = TRUE;
	  }
	  break;
	case OP_GET_DATA:
	  if(mine.has_init==FALSE)mine.fail=TRUE;
	  if(!mine.fail)
	  {
		
	  }
	  break;
	default:
		mine.fail=TRUE;
	  break;
	} //switch(op)
	return &mine;
}  //mrrrcontents_tree_view()



void mrrrsites_tree_view_init(mrrrsites_tree_view_ref_t* mine, gpointer arg)
{
/*
g_printf("[%s() is invoked]\n",__func__);
	GtkTreeIter treeiter;
	GtkCellRenderer *renderer;
	GtkTreeViewColumn *column;

	mine->list_store = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING);
	mine->treeview = GTK_TREE_VIEW(glade_xml_get_widget(mine->ref->xml, "" ))
  g_printf("show host name start\n");
  gchar* ret_hostname;
  if(g_mirrors_site_first_hostname(&ret_hostname))
  {
    do{
	gchar* ss;
	gchar empty_str[]="";
	g_printf("hostname = %s , ftp = %s\n", ret_hostname, g_mirrors_site_get(ret_hostname,"ftp",&ss)? ss: empty_str );
	if(ss=NULL)g_free(ss);
	g_free(ret_hostname);
    }while(g_mirrors_site_next_hostname(&ret_hostname));
  }
  g_printf("show host name end\n");
*/



} //mrrrsites_tree_view_init()

void mrrrsites_tree_view_connect_selection(mrrrsites_tree_view_ref_t* mine, gpointer arg)
{



} //mrrrsites_tree_view_connect_selection()

void mrrrcontents_tree_view_init(mrrrcontents_tree_view_ref_t* mine, gpointer arg)
{




} //mrrrcontents_tree_view_init()






struct FtpFile {
  const char *filename;
  FILE *stream;
};

static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)
{
  struct FtpFile *out=(struct FtpFile *)stream;
  if(out && !out->stream) {
    /* open file for writing */
    out->stream=fopen(out->filename, "wb");
    if(!out->stream)
      return -1; /* failure, can't open file to write */
  }
  return fwrite(buffer, size, nmemb, out->stream);
}



gboolean im_core_ftp_download(const gchar *url, const gchar *filepath, gint timeout_second)
{

  g_printf("(%s:%d)[%s(url=%s,filepath=%s, timeout_second=%d) invoked]\n", __FILE__, __LINE__, __func__,url, filepath, timeout_second);

  gboolean is_valid=TRUE;
  CURL *curl;
  CURLcode res;
  //struct FtpFile ftpfile={"curl.tar.gz", NULL };
  struct FtpFile ftpfile={filepath, NULL};

  //curl_global_init(CURL_GLOBAL_DEFAULT);
   //curl_global_init(CURL_GLOBAL_DEFAULT);
//CURL_GLOBAL_ALL


//g_printf("(%s:%d)[%s()] checkwrong\n",__FILE__, __LINE__, __func__);
#if 1
  curl = curl_easy_init();
//curl_easy_init();
  if(curl) {
  //if(1){
    //curl_easy_setopt(curl, CURLOPT_URL, "ftp://ftp.sunet.se/pub/www/utilities/curl/curl-7.9.2.tar.gz");
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout_second);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV , 0); //1 is mean that using EPSV before PASV
    /* Define our callback to get called when there's data to be written */
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
    /* Set a pointer to our struct to pass to the callback */
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ftpfile);

    /* Set The callback func for Progress Bar*/
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, FALSE);
    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);
    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, NULL);

     /* Switch on full protocol/debug output */
    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

     res = curl_easy_perform(curl);
     /* always cleanup */
    curl_easy_cleanup(curl);
    if(CURLE_OK != res) 
    {
      /* we failed */
      fprintf(stderr, "curl told us %d\n", res);
      is_valid=FALSE;
    }
  }
   if(ftpfile.stream)
      fclose(ftpfile.stream); /* close the local file */
   curl_global_cleanup();
#else


  //CURLcode res;
  CURLM *multi_handles = NULL;
  if(!multi_handles) multi_handles = curl_multi_init();
  if(!multi_handles) 
  {
    g_printf("(%s:%d)[%s()] curl told us %s \n", __FILE__, __LINE__, __func__, CURLE_OUT_OF_MEMORY);
    is_valid=FALSE;
    return is_valid;
  }

  curl = curl_easy_init();
  if(curl) //setting CURL
  {
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout_second);
    curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV , 0); //1 is mean that using EPSV before PASV
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ftpfile);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, FALSE);
    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);
    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, "");
    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
  }

  if(curl_multi_add_handle(multi_handles,curl))
  {
    curl_multi_cleanup(multi_handles);
    is_valid=FALSE;
    g_printf("(%s:%d)[%s()] curl told us %s \n", __FILE__, __LINE__, __func__, CURLE_FAILED_INIT);
    return is_valid;
  }

  int still_running = 0;
  while(curl_multi_perform(multi_handles, &still_running) ==  CURLM_CALL_MULTI_PERFORM );
  if((!still_running))
  {
     curl_multi_remove_handle(multi_handles, curl); 
     curl_easy_cleanup(curl); 
  }
#endif 



   //im_gui_progress_open();
   //im_gui_progress_set_value(22);
   //im_gui_progress_set_value(100);
   //im_gui_progress_close();
   return is_valid;
} //im_core_ftp_download()

const gchar* im_core_get_download_dir(void)
{
	static gchar download_dir[255];
	static gboolean has_set=FALSE;
	if(has_set==FALSE)
	{
		g_sprintf(download_dir,"%s/.oxim/tables/%s/",g_get_usertmp_dir(), g_get_user_name());
		has_set=TRUE;
	}
	return download_dir;
} //im_core_get_download_dir()
void im_core_tab_pool_clear(void)
{
	if(1) //to build a /tmp/.oxim/tables/ if the Dir is not exist. and the clear all file in /tmp/.oxim/tables/$(username)
	{
	  static gchar filepath[256];
	  g_sprintf(filepath, "%s/.oxim/tables/%s", g_get_usertmp_dir(),g_get_user_name());
	  g_dir_mkpath("/",filepath);
	  g_dir_curdir_push();
	  g_chdir(filepath);
	  GError *error = NULL;
	  //traversal all file and remove all file in /tmp/.oxim/tables/$(username)
	  GDir* gdir = g_dir_open(filepath, 0,&error);
	  if(error!=NULL)
	  {
		g_print(error->message);
		g_clear_error(&error);
	  }
	  else
	  {
	  	g_dir_rewind(gdir);
		  const gchar* tmp_file;
		  tmp_file = g_dir_read_name(gdir);
		  while(tmp_file!=NULL)
		  {
			g_remove(tmp_file);
			tmp_file = g_dir_read_name(gdir);
		  }//while (tmp_file!=NULL)
		  g_dir_close(gdir);
	  }
	  g_dir_curdir_pop();
	  
	}//if(1) //to build a /tmp/.oxim/tables/ if the Dir is not exist. and the clear all file in /tmp/.oxim/tables/
} //im_core_tab_pool_clear()

void im_core_tab_pool_add_im(const gchar *im_name, const gchar* filepath_cin_gz)
{
  //gint len=0;
  //gchar* filepath_tab;	
  static gchar cmd[255];

  g_printf("(%s:%d)[%s(im_name=%s, filepath=%s) invoked]\n", __FILE__, __LINE__, __func__,im_name,filepath_cin_gz);
  if(1)
  {
    gint len=0;
    while(filepath_cin_gz[len]!='\0')len++;
    if(g_utf8_str_equal(&filepath_cin_gz[len-4],".tab"))
    {
	
  g_printf("(%s:%d)[%s(im_name=%s, filepath=%s) invoked]\n", __FILE__, __LINE__, __func__,im_name,filepath_cin_gz);
	g_sprintf(cmd,"install -Dm 644  %s %s/.oxim/tables/%s/%s.tab", filepath_cin_gz, g_get_usertmp_dir(), g_get_user_name(),im_name);
	system(cmd);
    }
    else
    {
  g_printf("(%s:%d)[%s(im_name=%s, filepath=%s) invoked]\n", __FILE__, __LINE__, __func__,im_name,filepath_cin_gz);
	g_sprintf(cmd,"oxim2tab -o %s/.oxim/tables/%s/%s.tab %s", g_get_usertmp_dir(),g_get_user_name(),im_name,  filepath_cin_gz);
	system(cmd);  
    }
  }
 // g_sprintf(cmd,"cp %s/.oxim/tables/%s/%s.tab %s/.oxim/tables/",g_get_usertmp_dir(),g_get_user_name(),im_name, g_get_userhome_dir() );
 // system(cmd);
  g_oxim_conf_add_imtable(im_name);
  if(1) //add im on list_store ... presume that ... there is no any build-in chinese input
  {
    GtkListStore* list_store = global->im_tree_view->list_store;
    //GtkTreeView* treeview = global->im_tree_view->treeview;
    GtkTreeIter iter;

    gboolean turn_on;
    gboolean default_on;
    static gchar input_method_name[100];
    static gchar input_method_alias_name[100];
    gint fast_key;
    gboolean im_buildin;

    if(1)//set turn_on, default_on, input_method_name, input_method_alias_name, fast_key, im_buildin
    {
	gboolean *bb;
	gint *ii;
	gchar *ss;
	const gchar *im = im_name;
	gchar empty_str[]="";
	gchar empty_chi_name[]="empty_chi";
#define GET(a,b,c,d) g_oxim_conf_get((a),(b),(c),(d))
	turn_on =  (GET(im,"Circular",&bb,VT_BOOL)) ? *bb : FALSE;
	

	//GET("SystemSetting","DefauleInputMethod",&ss,VT_STRING);
	//default_on = g_utf8_str_equal(ss,im);
	default_on=FALSE;
	
	//set input_method_name by OriginalChineseName in oxim.conf
	g_utf8_str_assign(input_method_name,(GET(im,"OriginalChineseName",&ss,VT_STRING))?ss:empty_chi_name);

	//set input_method_alias_name by AliasName in oxim.conf
	g_utf8_str_assign(input_method_alias_name,(GET(im,"AliasName",&ss,VT_STRING)) ? ss:empty_str);
			
	//set fast_key according to SetKey of oxim.conf
	fast_key = (GET(im,"SetKey",&ii, VT_INT))? *ii :-1;
			
	//set im_buildin if it is buildin InputMethod
	im_buildin=(	g_utf8_str_equal(im,"cnsphone")||g_utf8_str_equal(im,"cnscj")||
 			g_utf8_str_equal(im,"chewing")||g_utf8_str_equal(im,"unicode")) ? TRUE : FALSE;	
#undef GET
    }    


    gtk_list_store_append(list_store, &iter);
	gtk_list_store_set(list_store, &iter, 
		IM_REC_TURN_ON,			turn_on, 
		IM_REC_DEFAULT_ON,		default_on, 
		IM_REC_INPUT_METHOD_NAME,	input_method_name, 
		IM_REC_INPUT_METHOD_ALIAS_NAME,	input_method_alias_name, 
		IM_REC_FAST_KEY,		fast_key, 
		IM_REC_IM_BUILDIN,		im_buildin, 		
	 -1);

  }
#if 0
//Here will if 0 if you want to fixed the bug of oxim-setup about add_im 
  g_oxim_conf_update();
  //g_oxim_conf_reload();

  //if(im_tree_view( global->im_tree_view, OP_INIT, NULL)->fail)		g_printf("(%s:%d)[%s()]im_tree_view init fail\n", __FILE__, __LINE__, __func__);

#endif 
  
} //im_core_add_new_im()

gboolean im_core_im_has_exist(const gchar *filename_cin_gz)
{
  g_printf("(%s:%d)[%s(filename_cin_gz=%s) invoked]\n", __FILE__, __LINE__, __func__,filename_cin_gz);

  static gchar im_name[100];
  g_utf8_str_assign(im_name, filename_cin_gz);
  gint len=0;
  while(im_name[len]!='\0')len++;
  im_name[len-7]='\0';

#if 0
  static gchar filepath[256];
  //exist property is made by testing ~/.oxim/tables/*.tab
  g_sprintf(filepath, "%s/.oxim/tables/%s.tab", g_get_userhome_dir(), im_name);
  return g_file_test(filepath, G_FILE_TEST_EXISTS);
#else
  //exist property is made by testing g_oxim_conf
  return g_oxim_conf_has_imtable(im_name);
#endif 
  
} //im_has_exist()




static gchar data_default_font_name[255];
static void set_default_font_name(const gchar* set_data)
{
	g_utf8_str_assign(data_default_font_name, set_data);
}
static const gchar* get_default_font_name(void)
{
	return data_default_font_name;
}



int progress_callback(GtkWidget* bar,  double dltotal, double dlnow,  double ultotal, double ulnow)
{
  g_printf("%f / %f (%f %%)\n", dlnow, dltotal, dlnow*100.0/dltotal);
  //gtk_progress_set_value(GTK_PROGRESS(bar), dlnow*100.0/dltotal);
  return 0;
}


gboolean popup_im_menu(GtkWidget* eventbox, GdkEventButton *event, GtkWidget* menu)
{ 
  if(event->type!=GDK_BUTTON_PRESS) return FALSE;
  if(event->button != 3) return FALSE;
  right_popup_menu = menu;
  //gtk_menu_popup(menu, NULL, NULL, NULL, NULL, event->button, event->time);
  //mouse_right_button_is_clicked = TRUE;
  g_printf("(%s:%d)[%s()] Event received\n", __FILE__, __LINE__, __func__);

  //return TRUE;
  return FALSE;
}//popup_im_menu()

void menu_item_test(GtkMenuItem* item, gchar* str)
{
  g_printf("(%s:%d)[%s()] %s is pressed\n", __FILE__, __LINE__, __func__, str);

}
